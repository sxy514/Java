一、面向对象技术
  面向对象技术是一种软件开发方法，在面向对象程序设计方法出现之前，软件界广泛流行的是面向过程的设计方法，这种方法中使用的众多变量名和函数名互不约束，令程序员不堪重负。
  随着开发系统规模的不断扩大，面向过程的方法越来越不能满足开发人员的要求，面向对象技术应运而生，这种新技术使得程序结构简单，相互协作容易，更重要的是程序的重用性大大提升。
  所谓面向对象的方法学，就是使得分析、设计和实现一个系统的方法尽可能地接近人们认识一个系统的方法。
  通常分为三个方面：面向对象的分析(OOA)、面向对象的设计(OOD)、面向对象的程序设计(OOP)。面向对象技术包含的概念主要有抽象、对象、类、类型层次(子类)、封装、继承性、多态性等。
  Java语言是一种“纯”面向对象语言，它的所有数据类型，包括最基本的布尔型、数值型及字符型，都有相应的类，程序可以完全基于对象来编写。
  
二、OOP
  现实世界中存在很多同类的对象，他们来自于同一种原型，具有一样的共性。或者说它们来自与同一个模板。这就是类的概念。这其中的某个特定实体即为实例或称对象。对象是类的具相，类是对象的抽象。
  OOP技术把问题看成是相互作用的事物的集合，也就是对象的集合。对象具有两个特性，一是状态，二是行为。状态是指对象本身的信息，行为是实现对对象的操作。在OOP中，用属性来描述状态，而把对它的操作定义为方法。-->
  --> 属性也称为数据，这样的对象就是数据加方法。可以将现实生活中的对象经过抽象、映射为程序中的对象，
  OOP中采用了三大技术：封装、继承和多态。封装体现的特点是将对象的属性及实现细节隐藏起来，只给出如何使用的信息。
  1.封装：将数据及对数据的操作捆绑在一起成为类，这就是封装技术。对象是类的实例，外界使用对象中的数据收到类定义的限制
  2.继承：将一个已有类中的数据和方法保留，并加上自己特殊的数据和方法，从而构成一个新类，这是OOP中的继承。原来的类是父类，也称为基类或超类。新类是子类，子类派生与父类，或说子类继承父类。继承体现的是一种层次关系，下一层的类可以从上一层的类继承定义，同时还可以改变和扩充一些特性
  3.多态：在一个类或多个类中，可以让多个方法使用同一个名字，从而形成多态性。多态可以保证对不同类型的数据进行等同的操作，名字空间也更加宽松。多态还有一个重要的特点，即使用相同的操作名，能根据具体的对象自动选择对应的操作。
  
  
第二章第一节：
一、空白，注释及语句
  1.空白：在Java程序中，换行符和回车符都可以表示一行的结束，它们可以被看作空白。应该注意代码的格式，增加可阅读性
  2.注释：程序中适当的加入注释可以增加易读性，注释有三种形式：1.// 在一行内的注释  2./* 一行或者多行注释 */  3./** 文档注释 */ 
  3.语句、分号和块：语句是Java程序的最小执行单位，程序的各语句间以“;” 分隔。在 “{}” 内的一系列语句成为语句块。

二、关键字
  Java语言定义了许多关键字，关键字也称为保留字。它们都有各自的特殊意义和用途，不能把它们当成普通的标识符使用。
  Java关键字如下：
  abstract	 boolean    break	 byte	case 	cast	catch	char	class	const	continue	default		do 		double		else  	extends		false	 final	 finally	float	for
  future	generic		goto	 if		implements		import		innner		instanceof	  int		interface		long 	native		new		null	 operator	outer	 package	private		
  protected	 public		rest	return	short	static	strictfp	super		switch		synchronized(线程同步)	 this		throw	 throws		transient	 true	try		var		void  	volatile	while
  定义的这些关键字中，少数几个已不再使用。还有几个是预留的关键字，目前尚未使用。这些关键字是：cast, const, future, generic, goto, inner, operator, outer, rest和var等
 
三、标识符
  在Java中，标识符由字母、数字、下划线(_)或美元符号（$）组成的字符串，其中数字不能作为标识符的开头。标识符区分大小写，长度没有限制。除以上所列几项外，标识符中不能含有其他符号，当然也不许留空白，在程序中，标识符可用作变量名，方法名、接口名和类名等。
  Java源代码使用的是unicode码，而不是ASCII码

四、Java编程风格
  在编程时，应当注意自己的编程风格，增加必要的注释和空格，采用缩进格式。
  以下是常见的命名约定：
  1.类名或接口名：多为动词，含有大小写，首字母大写，其余各单词首字母大写。如HelloWorld..
  2.方法名：多是动词，含有大小写，首字母小写，其余各单词首字母大写，尽量不要在方法名中使用下划线。如getName\setAdress等
  3.常量名：简单类型常量的名字应该全部为大写字母，单词与单词之间用下划线分隔，对象常量可以使用混合大小写，如BLUE_COLOR。
  4.变量名：所有的实例变量，类变量，终极变量和静态变量等都使用混合大小写，首字符为小写，后面单词的首字母用大写。变量名中尽量不要使用下划线。如balance, orders等
  命名名称要有意义，尽量避免使用单字符名字，除非是临时使用的要“扔掉”的变量（比如在循环结构中的循环变量），总的来说就是要增加代码的可读性
 
第二节、基本数据类型
  Java的数据类型共分为两大类，一类是基本数据类型，另一类是复合数据类型。基本类型有八种，分为4小类，分别是整型，浮点型，字符型，和布尔型。整型和浮点型也合称为数值型。复合数据类型包括数组，类和接口。其中，数组也是一个很特殊的概念，它是对象，而不是一个类，一般把它归为复合数据类型。
  1.Java语言提供了4种整型量，对应的关键字分别是：byte, short, int 和 long。 它们的字节大小和可表示的范围分别是：
    byte(整数长度8位,字节数1)= -2的7次幂 ～ 2的7次幂-1 (-128~127)
    short(整数长度16位，字节数2)= -2的15次幂 ～ 2的15次幂-1（-32768～32767）
    int(整数长度32位，字节数4)= -2的31次幂 ～ 2的31次幂-1（-2,147,483,648～2,147,483,647）
    long(整数长度64位，字节数8)= -2的63次幂 ～ 2的63次幂-1（-9,223,372,036,854,775,808～9,223,372,036,854,775,807）
    整型常量是int型的。如果想表示一个长整型常量，需要在数的后面明确写出字母“L”。L表示它是一个long型量。这里，使用大写L或者小写l均有效。Java语言还提供了几个特殊的整型常量值表示最大值和最小值（比如int类型最大值为: integer.MAX_VALUE;最小是为integer.MIN_VALUE）
 
  2.Java浮点数类型遵从标准的浮点规则。浮点数类型有两种：一种是单精度浮点数，用float关键字说明;另一种是双精度浮点数，用double关键字说明，它们都是有符号数。
    float(浮点数长度32位，字节数4)= 1.4e-45f ~ 3.4028235e + 38f
    double(浮点数长度64位，字节数8)= 4.9e-324d~1.7976931348623157e + 308d
    如果数值常量中包含小数点，指数部分（字符E），或数的后面跟有字母F或字母D，则为浮点数。浮点数常量在默认情况下是double型的，除非用字母F明确说明它是float型。浮点型常量中的字母D或者F支持大小写。
    Java语言中有几个特殊的浮点数常量：float/double类型通用（最大值：Float.MAX_VALUE; 最小值：Float.MIN_VAlUE; 正无穷大：Float.POSITIVE_INFINITY; 负无穷大：Float.NEGATIVE_INFINITY; 0/0: Float.NaN;）
 
  3.字符类型char：单个字符用char类型表示。一个char表示一个Unicode字符，其值用16位无符号整数表示，范围为0～65535。char类型的常量值必须用一对单引号('')扩起来，分为普通字符常量和转义字符常量两种。
    使用单引号括住一个字符，表示一个普通的字符常量。但有些字符在Java语言中有特殊含义，常用转义符： \b表示退格键 \n表示换行符 \r表示回车符 \t表示水平制表符 \\表示一个反斜杠 \'表示一个单引号 \"表示一个双引号
  
  4.布尔类型boolean：逻辑值有两种状态，它们常被写作on和off，true和false，yes和no等。布尔类型也称为逻辑类型。bool类型有两个常量值：true和false，它们全是小写，在计算机内部用8位二进制数表示。
    Java是一种严格的类型语言，它不允许数值类型和布尔类型之间进行转换。不能向C/C++那样允许用数值表示逻辑值，如用0表示false，非0表示true。Java不允许这样做，需要使用逻辑值的地方不能以其他类型的值替代

第三节、表达式
  表达式由运算符和操作数组成，对操作数进行运算符指定的操作，并得出运算结果;
  Java运算符按功能可分为：算术运算符/ 关系运算符/ 逻辑运算符/ 位运算符/ 赋值运算符/ 条件运算符，除此之外，还有几个特殊用途的运符，如数组下标运算符等。操作数可以是变量，常量或方法调用等
  1.操作数：有常量和变量之分，只有简单数据类型和String类型才有相应的常量形式，变量是存储数据的基本单元，它可以用作表达式中的操作数，变量在使用之前要先声明。
    有时把类类型的变量称为引用。在声明变量的同时给变量赋了初值，称为对变量进行了初始化。 声明变量的地方有两处，一处是在方法内，另一处是在类定义内。方法内定义的变量称为自动变量，也称为局部变量、临时变量或栈变量。类中定义的变量是类的成员变量。
    Java程序中不允许将未经初始化的变量用作操作数。
    变量作用域：变量的作用域是值可访问该变量的代码范围。类中定义的成员变量的作用域是整个类。方法中定义的的局部变量的作用域是从该变量的声明处开始到包含该声明的语句块结束处，块外是不可用的。
  
  2.运算符
    2.1 算术运算符：算术运算符包括通常的加(+)、减(-)、乘(*)、除(/)、取模(%),完成整型和浮点型数据的运算。许多语言中的取模运算符只能用于整型数据，Java对此有所拓展，它允许对浮点数进行取模操作，例如 15.2 % 5 的结果是 0.2，取模还可以用于负数，结果的符号与地一个操作数符号相同。
    此外，算术运算符还有“++”和“--”自增和自减运算符，这两个运算符有前缀形式和后缀形式，++i和i++的执行顺序不一样，++i在i使用之前先加1,i++在i使用过后再加1,--i和i--的情况与此类似。
  
    2.2 关系运算符：关系运算符用来比较两个值，包括大于(>)、小于(<)、大于等于(>=)、小于等于(<=)、等于(==)和不等于(!=)6种。关系运算符都是二元运算符，也就是每个运算符都带有两个操作数。运算的结果是一个逻辑值。
    Java允许“==”和“！=”两种运算用于任何数据类型。例如，可以判断两个实例是否相等。
  
    2.3 逻辑运算符：逻辑运算符包括逻辑与(&&)、逻辑或(||)、逻辑非(!)。前两个是二元运算符，后一个是一元运算符。
  
    2.4 位运算符：位运算符用来对二进制位进行操作，包括按位取反(~)、按位与(&)、按位或(|)、异或(^)、右移(>>)、左移(<<)、及无符号右移(>>>)。位运算符只能对整型和字符型数据进行操作。运算在八位二进制下进行。
    Java提供两种右移运算符。运算符“>>”执行算术右移，它使用最高位填充移位后左侧的空位。右移的结果为：每移一位，第一个操作数被2整除一次，移动的次数由第二个操作数确定。
    逻辑右移运算符(也称为无符号右移运算符) >>>只对位进行操作，而没有算术含义，它用0填充左侧的空位。算术右移不改变原数的符号，而逻辑右移不能保证这一点。
  
    2.5 其他运算符：Java中的运算符还包括拓展赋值运算符(+=、-=、*=、/=、%=、&=、|=、^=、>>=、<<=和>>>=）、条件运算符(?:)、点运算符(.)、实例运算符(instan-ceof)、new运算符及数组下标运算符([])等。
    条件运算符(?：)是三元运算符，它的一般形式为：逻辑表达式 ? 语句1：语句2;  其中逻辑表达式得到一个逻辑值，根据该值的真假决定执行后续操作。逻辑值为真执行语句12,否则执行语句2。语句1和语句2需返回相同类型的值，且不能为void。
  
    2.6运算符的优先次序：在对一个表达式进行运算时，如果表达式中含有多种运算符，则要按运算符的优先次序依次从高到低进行，同级别的运算符则根据结合律自左向右或自右向左进行。括号可以改变运算次序。
  
  3.表达式的提升和转换：
    Java是一种强类型语言，不支持变量类型间的自动任意转换，有时必须显式地进行变量类型的转换。不同类型的数据先转换为同类型然后再进行运算。转换的一般原则是位数少的类型转换为位数多的类型，这称为自动类型转换。这样做的目的是保证转换时不丢失有用信息。
    能够进行自动类型转换的类型顺序为：byte、short、char、int、long、float、double。排在前面的类型可自动转换为排在后面的类型

第二章小结：本章介绍了Java程序的一些基本语法知识，包括空白、注释、关键词及标识符、数据和表达式等。着重介绍了Java语言命名标识符规则，列出了所有的关键字。介绍了8种基本数据类型，包括表示它们的关键字，各类型的表示范围，各类型常量值的含义、转义符的含义等。
本章还介绍了运算符的含义及其优先级，变量的声明、初始化、赋值方法及其作用域、Java表达式的表示方法、表达式提升和转换方法也是本章的重点。
   
   
第三章 流程控制语句：
第一节、Java程序的结构：
  一个Java程序可以由一个或多个.java文件组成，这些文件称为源文件。每个源文件中含有一个或多个类或接口。一个源文件中如果有多个类，则最多只能有一个是public类型的类，且该源文件的名字则为这个公有类的名字，且大小写一致。其他非public的类的个数不限。
  一个Java程序的结构包含以下内容：
   package语句：  包语句，每个文件最多只有一个，且必须放在文件开始的地方。
   import语句：  引入语句，可以没有，也可以有多个，如果有import语句的话，必须放在所有类定义的前面。
   具有public权限的类定义：  每个文件中最多有一个。
   类定义：  每个文件中包含的非public权限的类定义的个数没有限制。
   接口定义：  每个文件中包含的接口定义个数没有限制
  
  1.1 Java包的概念
    包是类的容器，包的设计人员利用包来划分名字空间，以避免类名冲突。Java中的包一般均包含相关的类，使用包的目的就是将相关的源代码文件组织到一起。
    程序中如果有package语句，该语句一定是源文件中的第一条非注释语句，它的前面只能有注释或空行。另外，一个文件中最多只能有一条package语句。包的名字有层次关系，各层之间以点分隔。
  
  1.2 引入语句
    假设已定义如下的包：
    package mypackage;
    public class MyClass {....}
    如果其他人在其他包中想使用MyClass类，则需要使用全名，如： mypackage.MyClass m = new mypackage.MyClass();
    为了简化程序的书写，Java提供了引入语句。当需要使用其他包中的类时，可以使用import语句引入需要的类，程序中无需在使用全名，语句简写为：import mypackage. *; MyClass m = new MyClass();
    从系统的角度来看，包名也是类名的一部分。包中类的名字“全称”是包名加类名。所以虽然不同的包中可能存在相同名称的类，但因为它们不在同一个包中，故类名还是不同的，从而可以尽最大可能避免名称冲突。从另一个角度看，这种机制提供了包一级的封装及存取权限。
  
第二节、流程控制
  Java程序中的语句指示计算机完成某些操作，一条语句的操作完成后会把控制转给另一条语句。语句是Java的最小执行单位，语句间以分号(;)作为分隔符。语句分为单语句及复合语句，单语句就是通常意义下的一条语句;而复合语句是一对大括号{}括起来的语句组，也称为“块”。
  2.1.赋值语句
    在Java程序中，表达式可以当作一个值赋给某个变量，这样的语句称为赋值语句。有的表达式也可单独当作语句，这样的语句称为表达式语句。	
  
  2.2 分支语句
    分支语句根据一定的条件，动态决定程序的流程方向，从程序的多个分支中选择一个或几个来执行。分支语句有if语句和switch语句两种。
    if语句：if语句是单重选择，最多只有两个分支。基本格式为： if(条件表达式) {语句1;} else {语句2;} 
    if关键字之后的条件表达式必须得到一个逻辑值，不能向其他语言那样用数值来代替。因为Java不提供数值与逻辑值之间的转换。
    if语句的三种常见形式：形式1，没有else子句。形式2,包含else语句。形式3,嵌套的if语句。
  
    switch语句：使用if语句可以实现简单的分支判断，并进而执行不同的语句。为了更方便地实现多重分支，Java语言还提供了switch语句，它的含义与嵌套if语句类似，只是格式上更加简洁。语法格式如下：
    switch (表达式) {
  		  case c1：
  			  语句组1;
  			  break;
  		  case c2：
  			  语句组2;
  			  break;
    } 这里，表达式的计算结果必须是int或char型，即是int型赋值相容的。当用byte或者short型时，要进行提升。Java规定switch语句不允许使用浮点型或long型表达式。c1，c2是int型或字符串型常量。default子句是可选的，
    switch语句的语义是：计算表达式的值，用该值依次和c1,c2相比较。如果该值等于其中之一则执行后面的语句组，直到遇到break语句跳到switch之后的语句。如果没有相匹配的case，则执行default之后的语句组。
    可以将default语句看作一个分支，即前面的条件均不满足时执行default。
  
  3.循环语句
    循环语句控制程序流多次执行一段代码。Java语言提供3种循环语句，分别是for语句、while语句和do语句。
    3.1 for(初始语句;条件表达式;迭代语句) {
  		  循环体语句;
      } //初始语句和迭代语句中可以包含有多个语句，各语句间以逗号分隔。for语句括号内的3个部分都是可选的，条件表达式为空时，默认规定为恒真。
      for语句的语义是：先执行初始语句，判断条件表达式的值，当条件表达式为真时，执行循环体语句，再执行迭代语句，然后去判别条件表达式的值。这个过程一直进行下去，知道条件表达式的值为假时，循环结束，转到for之后的语句继续执行。
      如果条件表达式的值永远为真，则循环会无限制的执行下去，直到系统资源消耗尽为止。比如for(;;){System.out.println("Always print!");}
  
    3.2 while语句：
    for语句中常常用循环控制变量显式控制循环的执行次数。当程序中不能明确地指明循环的执行次数时，可以仅用条件表达式来决定循环的执行与否。这样的循环用while来实现：
    while(条件表达式)：
      循环体语句;
    和if语句一样，while语句中的条件表达式亦不可用数值来代替。
    while语句的语义：计算条件表达式的值，当值为真时，重复执行循环体语句，直到条件表达式为假时结束。如果第一次检查时条件表达式为假，则循环体语句一次也不执行。如果条件表达式始终为真，则循环不会终止。
  
    3.3 do语句：
    do语句与while语句很相似。它把while语句中的条件表达式移到循环体之后。
    do语句的语法结构：
  	  do：
  		  语句：
  	  while(条件表达式);
    do语句的语义是:首先执行循环体语句，然后判断条件表达式的值，当值为真时，重复执行循环体语句，直到表达式的值为假时结束循环。不论条件表达式的值是真是假，do循环中的循环体至少执行一次。
  
  4.跳转语句：
  	Java抛弃了有争议的goto语句，代之以两条特殊的流控制语句：break和continue语句，它们用在分支语句或循环语句中，更方便的控制程序执行的方向。
    4.1 标号：
    标号可以放在任意语句之前，通常与for、while或do语句配合使用，其语法格式为：
    标号：语句;
  
    4.2 break语句：
    break语句可用于3类语句中，第一类是在switch语句中，第二类实在for、while及do等循环语句中，第三类是在语句块中。在switch语句及循环语句中，break的语义是跳过本块中余下的所有语句，转到快尾，执行其后的语句。
    循环语句中的break为跳过余下的语句，结束循环。break语句的第三种使用方法是在块中和标号配合使用，其语法格式为：
    int x = 20;
    out: for(;;) {
    		if(x == 20) break out;
    }
    System.out.println("after out block");
    在上述案例中，当if语句条件满足时，跳出out标记的循环，执行块后的语句，即执行输出语句，显示“after out block”。
  
    4.3 continue语句：
    在循环语句中，continue语句可以立即结束当次循环，开始执行下一次循环，当然执行前需要先判断循环条件是否满足。
    continue语句也可以和标号一起使用，其语法格式为： continue 标号;
    它立即结束标号标记的那重循环的当次执行，开始下一次循环。这种形式的语句可以用在多重循环中。
 
第三节、简单的输入/输出
  程序运行期间交互式地读入用户的输入并将计算结果返回给用户是一个基本要求。本节介绍Java提供的用于输入/输出的几个基本类。
  1.Scanner类
    Scanner类属于Java.util包。它提供了许多方法，可用来方便地读入不同类型的输入值。可查阅相关的API文档来详细了解。
    要调用Scanner类的方法，必须先创建一个对象。Java中使用了new运算符来创建，语句如： Scannner scan = new Scanner(System.in);
    在创建Scanner类的对象时，构造方法接收一个参数，这个参数代表了输入源。System.in对象代表标准输入流，默认指键盘。
    Scanner对象用空白(空格，水平制表符及回车换行符)作为输入的分隔元素。这些空白成为分隔符。也可以指定用其他符号作为分隔符。
    Scanner类的next()方法读入下一个输入对象，将它作为字符串返回。如果输入的是一串用空白分开的多个字，则每次调用nex()都会得到下一个字。nextLine()方法读入当前行的所有输入，直到行尾，然后作为字符串返回。
    Scanner类的不同方法，如nextInt()和nextDouble()，用来读入不同类型的数据。输入的数值类型必须与所声明的变量类型要赋值兼容。
  
  2.NumberFormat类和DecimalFormat类
    NumberFormat类提供对数值进行格式化操作的一般功能。不能使用new运算符实例化一个NumberFormat对象，只能直接使用类名调用一个特殊的静态方法来得到一个对象。
    比如： NumberFormat类中的getInstance()方法返回当前默认语言环境的默认数值格式，然后使用格式对象来调用format()方法，将参数按相应的模式格式化后作为字符串返回。
    String myString = NumberFormat.getInstance().format(myNumber);
    和NumberFormat类不一样，DecimalFormat类按惯例使用new运算符来实例化对象。它的构造方法要带一个String类型的参数，这个参数表示格式化处理模式。

第四节、处理异常
  Java语言把程序运行中可能遇到的错误分为两类，一类是非致命性的，通过某种修正后程序还能继续执行。这类错误称为异常(Exception)。如打开一个文件时，发现文件不存在。又比如说除0溢出、数组越界等。这一类错误可以借助程序员的处理来恢复。
  另一类是致命性的，即程序遇到了非常严重的不正常状态，不能简单地恢复执行，这就是错误。比如程序运行过程中内存耗尽。异常处理要考虑的问题包括：如何处理异常？把异常交给谁去处理？程序又该如何从异常中恢复？
  
  1. 异常及处理机制：
    为了解决异常问题，Java提供了异常处理机制，预定义了一个Exception类。当程序中发生异常时，通常不是简单地结束程序，而是转去执行某段特殊代码来处理这个异常，设法恢复程序继续执行。但是如果程序遇到错误时，往往不能从中恢复，因此最好的办法是让程序中断执行。
    在一个方法的运行过程中，如果发生了异常，称程序产生了一个异常事件，相应地生成异常对象。该对象可能由正在运行的方法产生，也可能由JVM生成。这个对象中包含了该异常必要的详细信息,包括所发生的异常事件的类型及异常发生时程序的运行状态.
    生成的异常对象传递给Java运行时系统,运行时系统寻找相应的代码来处理这个异常. 生成异常对象并把它提交给运行时系统的这一过程称为抛出(Throw)一个异常.
    Java运行时系统从生成对象的代码块开始进行回溯,沿方法的调用栈逐层回溯,寻找相应的处理代码,直到找到包含相应异常处理的方法为止,并把异常对象交给该方法处理. 这一过程称为捕获(Catch). 当发现并相应异常时,就是处理(Handle)了异常。
    简而言之，发现错误的代码可以“抛出”一个异常，程序员可以“捕获”该异常，如果可能则“处理”它，然后恢复程序的执行。

  2. 异常分类：
    Java语言在所有的预设包中都定义了异常类和错误类。Exception类是所有异常类的父类，Error类是所有错误类的父类，这两个类同时又是Throwable类的子类。虽然异常属于不同的类，但所有这些类都是标准类Throwable的后代。
    Throwable在Java类库中，不需要import语句就可以使用。异常分为三种：{ 1.受检异常，必须被处理。 2.运行时异常，不需要处理。 3.错误，不需要处理。}
      1.受检异常(Checked Exception)是程序执行期间发生的严重事件的后果。例如，如果程序从磁盘中读入数据，而系统找不到含有数据的文件，将会发生受检异常。这个异常所属类的类名是FileNotFoundException。发生错误的原因可能是文件丢失等等，写的好的程序通常都会预见这种问题并处理。
      Java类库中的所有类都是使用名字来描述异常原因的。这些类表示受检异常: ClassNotFoundException / FileNotFoundException / IOException / NoSuchMethodException 及 WriteAbortedException.
  
      2.运行时异常(Runtime Exception)通常是程序逻辑错误的结果。例如，数组下标越界导致ArrayIndexOutOfBounds异常。被0除导致ArithmeticException异常。虽然可以添加代码来处理运行时异常，但一般只需要修改程序中的错误即可。
      运行时异常的所有类都是类RuntimeException的子类，它是Exception的后代。
      Java类库中的这些类表示运行时异常: ArithmeticException /  ArrayIndexOutOfBoundsException / ClassCastException / EmptyStackException / IllegalArgumentException / IllegalStateException / indexOutofBoundsException / NoSuchElementException / NullPointerException 和 UnsupportedOperationException

      3.错误(Error)是标准类Error或其后代类的一个对象, Error是Throwable的后代。一般地，错误是指发生了不正确的情况，如内存溢出。这些情况都比较严重，一般程序很难处理。所以，即使处理错误是合法的，一般也不需要处理它们。
      运行时异常和错误称为不检异常(Unchecked Exception)。
    有些异常类在使用时必须要引入。例如，当在程序中使用IOException时，必须要使用import java.io.IOException;

  3.处理异常：
    当发生异常时，程序通常会中断执行，并输出一条信息。对所发生的异常进行处理的就是异常处理。异常处理的重要性在于程序不但能发现异常，还要能捕获异常。对于可能引发受检异常的方法，有两种选择：在方法内处理异常，或时告诉方法的调用者来处理。
    比如，方法method1 调用 method2，method2又调用method3，进而method3又调用method4。在方法method4中如果出现异常，则在调用栈中的任何一个方法都可以捕获并处理这个异常。
    要处理异常，必须先标出可能引起异常的Java语句，还必须决定要找哪个异常。处理异常的代码含有两段。第一段try块含有可能抛出异常的语句。第二段含有一个或多个catch块。每个catch块含有捕获及处理某中类型异常的代码。
    catch(IOException e)标识符 e 称为catch块参数，它表示catch块将要处理IOException对象。参数e表示一个实际的异常。作为一个对象，每个异常都有存取方法getMessage()，它返回抛出异常时创建的描述字符串。通过显示这个字符串可知所发生异常的性质。
    catch块执行完毕，执行它后面的语句。但是如果问题很严重，则catch块可以调用exit方法来中止程序，如 System.exit(0); 赋给函数System.exit的参数0，表示虽然遇到了一个严重问题，但程序是正常结束的。
    单一一个try块中的语句，可能会抛出不同类型异常中的任意一个。在这样的try块后的catch块需要能捕获多个类的异常。为此，可以在try块后写多个catch块。当抛出一个异常时，为了能使所写的catch块真正捕获到相应的异常，catch块出现的次序很重要。程序的执行流程进入到其参数与异常类型相匹配的第一个catch块 ———— 按照出现的次序
    例如，下列的catch块次序不好，因为用于FileNotFoundException的catch块永远不会被执行：
    catch(IOException e) { .... } 
    catch(FileNotFoundException e) { .... }
    按照这个次序，任何I/O异常都被第一个catch块捕获。因为FileNotFoundException 派生于IOException，所以FileNotFoundException异常是IOException异常的一种，将与第一个catch块的参数相匹配。幸运的是，编译程序可能会对这样的次序给出警告信息。
    正确的次序是：
    catch(FileNotFoundException e) { .... } 
    catch(IOException e) { .... }  //处理所有其他的IOException
    因为受检异常和运行时异常的类都以Exception为祖先，故应避免在catch中使用Exception，而是尽可能地捕获具体的异常，且先捕获最具体的。
    try-catch的语法格式如下：
    try {
      //可能抛出异常的代码
    } catch (异常类型1 e) {
      //抛出异常类型1时要执行的代码，可能包含：
      System.out.println(e.getMessage());
    } catch (异常类型2 e) {
      //抛出异常类型2时要执行的代码，可能包含：
      System.out.println(e.getMessage());
    } finally {
      // 必须执行的代码
    }
    其中，异常类型1、异常类型2是产生的异常类型。根据发生异常所属的类，找到相应的catch语句，然后执行其中的语句。尽量避免在try块或catch块中再嵌套try-catch块；
    不论是否捕获异常，都要执行finally后的语句。一般地，为了统一处理程序出口，可将要处理的内容放到finally后的代码段中。
    try后的大括号中的代码称为保护代码。如果在保护代码内执行了System.exit()方法，将不在执行finally后面的语句，这是不执行finally后面语句的唯一一种可能。

  4.公共异常：
    为了方便处理异常，Java预定义了一些常见的异常，下面列举几个常用到的异常。
    1.ArithmeticException
      整数除法中，如果除数为0，则发生异常，如这个表达式将引发ArithmeticException异常：int i = 12/0;
    2.NullPointerException
      如果一个对象还没有实例化，那么访问该对象或调用它的方法将导致NullPointerException异常。例如：
      image im [] = new image[4];
      System.out.println(im[0].toString());
      第一行创建了有4个元素的数组im，每个元素是image类型，系统为其进行初始化，每个元素的值为null，表明它还没有指向任何实例。第二行要访问im[0]，由于访问的是还没有进行实例化的空引用，因此会导致NullPointerException。
    3.NegativeArraySizeException
      按常规，数组的元素个数应是一个大于等于0的整数。创建数组时，如果元素个数是负数，则会引发NegativeArraySizeException异常。
    4.ArrayIndexOutOfBoundsException
      Java把数组看作是对象，并用length变量记录数组的大小。访问数组元素时，运行时环境根据length值检查下标的大小。如果数组下标越界，则将导致ArrayIndexOutOfBoundsException异常。

  5.抛出异常：
    Java要求如果一个方法确实引发了一个异常(当然Error或RuntimeException两类错误除外)，那么在方法中必须写明相应的处理代码。
    处理异常有两种方法。一种是try块和catch块，捕获到所发生的异常类，并进行相应的处理。当然，catch块可以为空，表示对发生的异常不进行处理。
    另一种方法是，不在当前方法内处理异常，而是把异常抛出到调用方法中。当不能使用合理的方式来解决不正常或意外事件的情形下，才抛出异常。
    方法内执行throw语句时会抛出一个异常，一般形式如：throw exception_object;
    throw语句创建了一个异常对象 exception_object ，如： throw new IOException(); 这个语句创建类IOException的一个新对象并抛出它。抛出异常类型时也应该尽可能地具体。
      相应地，在说明方法时，要使用这个格式： 访问权限修饰符 返回值类型 方法名(参数列表) throws 异常列表
      紧接在关键字throws后面的是该方法内可能发生且不进行处理的所有异常列表。各异常之间用逗号分隔。例如：public void troubleSome() throws IOException
      一般地，如果一个方法引发了一个异常，而它自己又不处理，就要由调用者方法进行处理。如果方法内含有一个抛出异常的throw语句，则要在方法头添加一个throws子句，而不是在方法体内捕获异常。一般地，抛出异常及捕获异常应该在不同的方法内。
      在方法头中用Java保留字throws来声明这个方法可能抛出的异常；在方法体中用保留字throw实际抛出一个异常。  注意，这两个保留字不要混淆；

第三章小结：包是Java大的独特概念，与此相关的语句包括package语句和import语句。
本章详细介绍了各主要语句的语法格式，使用它们可以编写出基本的程序。此外还介绍了简单的输入/输出语句。
要编写稳定性强的程序，必须对可鞥出现的错误进行处理。Java提供了异常处理机制，本章详细介绍了异常处理的概念及处理机制，包括try、catch、finally、throw 和 throws 的使用方法。介绍了预定义的若干异常，以及编写程序时要注意的事项。


第四章 面向对象程序设计：
第一节、类和对象：
  1.类的定义：
    类的定义也称为类的声明。类中含有两部分元素，分别是数据成员变量和成员方法。类定义的一般格式如下：
    修饰符 class 类名 [extends 父类名] {
      修饰符 类型 成员变量1;
      修饰符 类型 成员变量2;
      ......
      修饰符 类型 成员方法1(参数列表) {
        方法体
      }
      修饰服 类型 成员方法2(参数列表) {
        方法体
      }
      ......
    }
    其中,class是关键字,表明其后定义是一个类. 含有class这一行称为类头,后面大括号括住的部分称为类体. class前的修饰符可以有多个,用来限定所定义的类的使用方式. 类名是用户为该类所起的名字,它必须是一个合法的标识符,并尽量遵从命名约定.
    extends是继承关键子. 如果所定义的类是从某个父类派生而来,那么,父类的名字要写在extends之后。 类定义中的数据成员变量可以有多个。成员变量前面的类型是该变量的类型；类中的成员方法也可以有很多个，其前面的类型是该方法返回值的类型。如果没有返回值，则写void。方法体是要执行的真正语句。
    在方法体中还可以定义该方法内使用的局部变量，这些局部变量只在该方法内有效。方法的参数列表中可以含有0个或多个参数，每个参数的前面要指明该参数的类型。 类定义中的修饰符是访问权限修饰符，包括public,private和protected, 也可以不写，表示是默认修饰符。
    它们既可以用来修饰类，又可以修饰类中的成员，修饰符决定所修饰成员在程序运行时被访问的方式。具体来说，用public修饰的成员表示是公有的，也就是它可以被其他任何对象访问。类中限定为private的成员只能被这个类本身访问，在类外不可见。用protected修饰的成员是受保护的，只可以被同一个包及其子类的实例的对象访问。
    如果不写任何修饰符，则表明是默认的，相应的成员可以被所在包中的各类访问。
    关于类定义，总结如下：
    ①类定义中，类头与类体是放在一起保存的，整个类必须在一个文件中，因此有时源文件会很大。
    ②源文件名必须根据文件中的公有类名来定义，并且要区分大小写。
    ③类定义中可以指明父类，也可以不指明。若没有指明是从哪个类派生而来，则表明是从默认的父类Object派生而来。实际上，Object是Java所有类的直接或间接父类。Java中除Object之外的所有类均有一个且只有一个父类。Object是唯一没有父类的类。
    ④class定义的大括号之后没有分隔符 ";" 

  2.构造方法：
    构造方法是一类特殊的方法，有特殊的功能。构造方法的名字与类名相同，没有返回值，在创建对象实例时通过new运算符自动调用。同时为了便于创建实例，一个类可以有多个具有不同参数列表的构造方法，即构造方法可以重载。事实上，不论是系统提供的标准类，还是用户定义的类，往往都含有多个构造方法。
    例如：
    public class Xyz {
      int x;   // 成员变量
      public Xyz() { x = 0; } // 参数列表为空的构造方法
      public Xyz(int i) { x = i; } // 第一个参数的构造方法
    }
    在类Xyz中定义了两个构造方法，第一个方法的参数列表是空的，第二个方法带有一个int类型参数。在创建Xyz的实例时，可以使用下列两种形式：
    Xyz obj =  new Xyz(); // 使用第一个构造方法
    Xyz obj2 = new Xyz(5); // 使用第二个构造方法
    构造方法不能说明为native，abstract，synchronized或final类型，通常说明为public类型。构造方法不能从父类继承。另外，构造方法没有返回值。一般来说，构造方法应该为所有的成员变量赋初始值，成员变量的值亦称为对象的属性值。
    默认的构造方法：每个类必须至少有一个构造方法。如果程序员没有为类定义构造方法，系统就会自动为该类生成一个默认的构造方法。默认构造方法的参数列表及方法体均为空，所生成的对象的各属性也为零或空。如果类定义中已经含有一个或多个构造方法，则系统不会再自动生成默认的构造方法了。
    构造方法重载： 在进行对象实例化时可能会遇到许多不同情况，于是要求针对所给定的不同的参数，调用不同的构造方法。这时，可以通过在一个类中同时定义若干个构造方法，亦即对构造方法进行重载来实现。
    有些构造方法中会有重复的代码，或者一个构造函数可能包含另一个构造方法中的全部代码，为了简化代码，可以在其中一个构造方法中引用另一个构造方法。可以使用关键字this来指代本类中的其他构造方法。
    例如：构造方法的重载及引用
    public class Student {
      String name;
      int age;
      public Student(String s, int n) {  // 构造方法1
        name = s;
        age = n;
      } 
      public Student(String s) { // 构造方法2
        this(s , 20);
      }
      public Student() { // 构造方法3
        this("Unknown");
      }
    }
    在上面的示例中，第三个构造方法中没有任何参数，它调用this("Unknown"),实际上是把控制权转给了只带一个字符串参数的第二个构造方法，并为其提供了所需的字符串参数值"Unknown"。而第二个构造方法中，则通过调用this(s , 20),把控制权转给第一个构造方法，并为其提供了字符串参数"Unknown"和int类型参数的值20。
    this引用： this除了可以用在构造方法中之外，还可以用来指明要操作的对象本身。

  3.对象的创建和初始化
    实际上，类的定义相当于一个“模子”，声明一个个类类型变量的过程就像是拿着模子复制一个个的副本，程序中使用的就是这样的一个个对象。
    以上面的Student类为例，现在可以声明Student类型的变量：Student myObj; 
    声明变量后，在内存中为其建立了一个引用，此时它不指向任何内存空间。对象的引用也称为对象的句柄。之后需要使用 new 申请相应的内存空间，内存空间的大小依class的定义而定，并将该段内存的首地址赋给刚才建立的引用。
    换句话说，用class类型声明的变量并不是数据本身，而只是对数据的引用，要用new来进一步创建类的实例或叫对象本身。比如： myObj = new Student(); 调用 new 为新对象分配空间，就是要调用类的构造方法。
    在Java中，使用构造方法是生成实例对象的唯一途径。这个过程称为对象的实例化。说明一个引用变量仅仅只是预定了变量的存储空间，此时并没有相应的地址空间给实例使用。必须进行对象实例化之后，才有真正的实例出现。在调用new时，是否带有参数、带多少个、各是什么类型的参数，要视具体的构造方法而定。系统根据所带参数的个数和类型，调用相应的构造方法。
    类X的一个对象也称为类X的一个实例。创建对象实例的格式： 类名 对象名称 = new 类名(参数列表);
    当通过new为一个对象分配内存时，如果构造方法中没有为成员变量提供初始值，则Java进行自动初始化。对于数值变量，赋初值0；对于布尔变量，赋初值false；对于引用，即对象类型的任何变量，使用一个特殊的值null作为初值。最常用的初始化过程是使用new对对象进行实例化。
    以Date为例，以下描述了从类引用声明到创建实例的过程。
                              ————————————
    Date today     today     |    ????    |    声明引用
                              ————————————
    .....................................................
    today = new Date();       ————————————
                   day       |    0       |   
                   month     |    0       |  ⬅ ——
                   year      |    0       |       |  创建对象类的实例
                              ————————————        |
                                                  |    
                  today       ————————————        |
                             | 0x01abcdef |  —— ——
                              ————————————
    声明了today后，它的内存中没有存放任何值(上图中表示为????)。只当实例化后，也就是指向了new Date()语句后，才在内存中分配了Date实例的地址，并在相应的3个成员变量内存中存放了初值0.同时将这个实例的首地址存放的引用today内。
    给定类Xxx的类定义，调用new Xxx()创建的每个对象都区别于其他对象，并有自己的引用。该引用存储在相应的类变量中，然后也可以使用点操作符来访问每个对象中的各独立成员。
    使用对象中的数据和方法的格式如下：
      对象引用.成员数据
      对象引用.成员方法(参数列表);
    因为引用的特殊性，故给引用赋值时，它的含义与基本类型变量的赋值不一样。引用的赋值时将句柄赋值给另一个引用，它们都是指向同一个内存堆，所以它们的数值都是一样的。
    在Java中，null值表示引用不指向任何对象。程序运行过程中系统若发现使用了这样一个引用时，可以立即停止进一步的访问，不会给系统带来任何危险。

第二节、定义方法：
  1.方法的定义：
    对对象的操作体现在成员方法上。说明为private的成员变量，在类外，不能通过点操作符直接访问，必须通过成员方法才能访问。一般来讲，成员变量应尽量声明为private的，同时提供一组相关的访问方法供其他类使用。
    在Java中，方法定义的一般格式如下：
      修饰符 返回类型 方法名(参数列表) 块
      关于方法定义的说明如下。
      ①方法名必须是一个合法的标识符。
      ②返回类型是方法返回值的类型。如果方法不返回任何值，则应声明为void。Java对待返回值的要求很严格，方法返回值必须与所声明的类型相匹配。如果方法声明有返回值，比如说int，那么方法从任何分支返回时都必须返回一个整数值。
      ③修饰符段可以含有几个不同的修饰符，其中限定访问权限的修饰符包括public、private和protected。
      ④参数列表是传送给方法的参数表。表中各元素以逗号分隔，每个元素由一个类型和一个标识符表示的参数组成。
      ⑤块表示方法体，是要实际执行的代码段，是由一对大括号括起来的语句序列。方法体中一般使用return语句表示方法的结束。如果方法的返回类型不是void，则需要在return语句中指明方法的返回值。
  
  2.按值传送
    调用方法时，通常会给方法传递一些值。传给方法的值称为实参，方法的参数列表中列出的值称为形参。
    Java“按值”传送实参。如果形参是基本数据类型的，则调用方法时，将实参的“值”复制给形参。返回时，形参的值并不会带回给实参，即在方法内对形参的任何修改，都不会影响实参的值。
    如果形参是引用，则调用方法时传递给形参的是一个地址，即实参指向的对象的首地址。方法返回时，这个地址也不会被改变，但是地址内保存的内容是可以改变的。因此，当从方法中退出时，所修改的对象内容可以保留下来。

  3.重载方法名
    允许多个方法使用同一个方法名，这就是方法名的重载(Overload)。一个类中，如果有多个方法的名字是一样的，为了在调用时不产生混乱，Java规定，方法的参数列表必须不完全相同。实际上，Java正是根据参数列表来查找适当的方法并进行调用的，这其中包括参数的个数及各参数的类型以及它们的顺序。
    一般地，方法名称加上方法的参数列表(包括方法中参数的个数、顺序和类型)称为方法签名。方法重载时，方法签名一定不能相同。在一个类的定义中，往往会有多个构造方法，根据初始化时的不同条件调用不同的构造方法，以生成不同的对象。
    重载方法有两条规定，分别如下所述：
      ①调用语句的实参列表必须足够判断要调用的是哪个方法。实参的类型可能要进行正常的拓展提升(如浮点数变为双精度数)，但在有些情况下会引起混淆。
      ②方法的返回类型可以相应也可以不同。两个同名方法仅有返回类型不同，而参数列表完全相同，这是不够的，因为在方法执行钱不知道能得到什么类型的返回值，因此也就不能确定要调用哪个方法。重载方法的参数列表必须不同。
  
第三节、静态成员：
  在类的定义中还可以定义一种特殊的成员，用static修饰，称为静态成员或类成员，包括静态变量和静态方法。静态成员是不依赖于特定对象的内容。Java运行时中系统生成类的每个实例对象时，会为每个对象的实例变量分配内存，然后才可以访问对象的成员，而且不同对象的内存空间相互独立，也就是说对于不同对象的成员，其内存地址时不同的。
  但是如果类中包含静态成员，则系统只在类定义时为静态成员分配内存，此时还没有创建对象啊。也没有对对象进行实例化。以后生成该类的实例对象时，将不再为静态成员分配内存，不同对象的静态变量将共享同一块内存空间。
  1.静态变量：
    在程序设计中，有时一个变量会被类的多个实例对象所共享，以实现多个对象之间的通信，或用于记录已被创建的对象的个数等。静态变量也被称为类变量，以区别于成员变量或实例变量。将一个变量定义为静态变量的方法就是将这个变量标记上关键字static。
    在Java中没有全局变量的概念，静态变量从某种意义上来说相当于其他程序设计语言中的全局变量。静态变量是唯一为类中所有对象共享的变量。如果一个静态变量同时还被定义为public类型，那么其他类也同样可以使用这一变量。
    而且由于静态变量的内存空间是在类的定义时就已经分分配的，因此引用这一变量时甚至无需生成该类的一个对象，而是直接通过类名来指向它。

  2.静态方法：
    与静态变量类似，如果需要在尚未创建一个对象实例的时候就去引用方法的程序代码，那么标记上关键字static即可实现。这样的方法称为静态方法，或称类方法。与之相对的，非静态方法有时也称为实例方法。静态方法不依赖于特定对象的行为。
    调用静态方法时，前缀使用的是类名，而不是对象实例名。如果从当前类中的其他方法中调用，则不需要写类名，可以直接写方法名。
    使用静态方法时，有两个特别的限制必须注意：
    ①由于静态方法可以在没有定义它所属的类的对象的情况下加以调用，故不存在this值。因此，一个静态方法只能使用其内部定义的参数或静态变量，如果想使用非静态变量将引起编译错误。
      例：错误的引用
        public class Wrong {
          int x;                                // 非静态变量
          public static void main(Srting args[]) {
             x = 9;                             // 无法从静态方法中引用非静态变量x
           }
        }
    ②静态方法不能被重写。也就是说，在这个类的后代类中，不能有相同名称，相同参数列表的方法。 关于方法的重写，将在第六章讨论。

第四节、包装类：
  Java使用的基本数据类型(如int、double、char和boolean)及类和对象来表示数据。要管理的数据仅有两类，即基本数据类型值及对象引用。但当想用处理对象一样的方式来处理基本类型的数据时，必须将基本类型值“包装”为一个对象。为此，Java提供了包装类。
  包装类表示一种特殊的基本类型。例如，Integer类表示一个普通的整型量。由Integer类创建的对象只保存一个int型的值。
  包装类的构造方法接受一个基本类型的值，并保存它，例如：Integer ageObj = new integer(40); 执行这条语句后ageObj对象就将整数40看作一个对象。它可以用在程序中需要对象而不是需要基本类型值的地方。
  对于Java中的每种基本数据类型，Java类库种都有一个对应的包装类。所有的包装类都定义在java.lang包中,如下：
  byte: Byte;  short: Short;  int: Int;  long: Long;  float: Float;  double: Double;  char: Character;  boolean: Boolean;  void: Void;
  注意，对应于void类型的包装类是Void。但和其他的包装类不一样的是，Void类不能被实例化，只表示void引用的概念。

  调用静态方法时不依赖于任何的实例对象。以perseInt为例，它将保存在字符串中的值转为对应的int型值。如果字符串对象str中的值是“987”，则最后的代码将字符串转为整型量987，并保存在int型变量num中：num = Integer.paseInt(str);
  自动将基本数据类型转换为对应的包装类的过程称为自动装箱(Autoboxing)。例如：
    Integer obj1;
    int num1 = 69;
    obj1 = num1;      //自动创建Integer对象
  逆向的转换称为拆箱(Unboxing)，需要时也是自动完成的。例如：
    Integer obj2 = new Integer(69);
    int num2;
    num2 = obj2;    //自动解析出int型
  一般来说，基本数据类型与对象之间的赋值是不相容的。自动装箱与自动拆箱仅能用在基本数据类型与对应的包装类之间。其他的情况，如将基本数据类型赋给对象引用变量，或是相反的过程，都会导致编译错误。

第四章小结：Java是面向对象的程序设计语言，它为用户提供了类，接口和数组，这些都是不同于基本数据类型的类型。本章介绍如何定义一个类，如何声明一个对象并进行初始化，如何编写构造方法及类中的方法。本章还介绍了访问修饰符的含义及使用。这些是面向对象程序设计中最基本的内容。
本章介绍了方法的按值传松机制，介绍了方法的重载及方法签名的概念。此外还介绍了静态成员的含义及调用规则，介绍了包装类的概念及与之相关的自动拆箱与装箱。


第五章 数组和字符串
第一节、数组：
  1.数组声明：
    一个数组是相同数据类型的元素按一定顺序排列的集合。使用数组可以将同一类型的数据存储在连续的内存位置。数组中各元素的类型相同，通过下标来访问数组中的元素，下标从0开始。在Java中，数组是对象。类Object中定义的方法都能用于数组对象。
    程序员可以声明任何类型的数组，具体来说，数组元素可以是基本数据类型，也可以是类类型或接口类型，当然还可以是数组。数组在使用之前必须先声明，也就是要先定义后使用。一维数组的定义格式为：类型 数组名[]; 其中，类型是数组元素的类型。数组名为合法的标识符，[]指明定义的是一个数组类型变量。
    还可以定义类类型的数组，比如：Date dateArray[]; 这个声明的数组，其元素都是类类型的，dataArray的每个元素都是类型Date的。
    在数组定义时并不会为数组分配内存，因此方括号[]中不需要指出数组元素的个数，即数组长度。和其他类型一样，数组声明并不创建数组对象本身。所以这些声明没有创建数组。声明的数组名只是引用变量，用来指向一个数组。
    Java还允许用另一种格式来声明数组，格式为: 类型[] 数组名; 比如: int[] intArray; 这个声明与前面的声明完全等价，在这种格式中，左面是类型部分，右面是变量名，与其他类型声明的格式一致。
    Java中没有静态的数组定义，这种写法是错误的: int intArray[5];
  
  2.创建数组:
    数组声明仅仅是定义了一个数组引用，系统并没有为数组分配任何内存，因此现在还不能访问它的任何元素。必须经过数组初始化后，才能使用数组的元素。初始化的过程就是数组的创建过程。
    数组的初始化分为静态初始化和动态初始化两种。所谓静态初始化就是在定义数组的同时给数组元素赋初值。静态初始化使用一对大括号将初值括起来，每个元素对应一个引用。例如: int intArray[] = {1,2,3};
    动态初始化：
    String names[];
    names = new String[2];
    names[0] = "person1";
    names[1] = "person2";
    上述语句使用的是动态初始化，使用运算符new为数组分配空间，这和所有对象是一样的。数组声明的方括号中的数字表示数组元素个数。
    对于基本数组类型的数组，其创建格式如下：
    类型 数组名[] = new 类型[数组大小];
    类型[] 数组名 = new 类型[数组大小];
    如果前面已经对数组进行了声明，则此处的类型可以不写。比如已经定义了char[] s; 则s = new char[20]; 将创建有20个字符的数组s。
    对于类类型的数组，使用运算符new只是为数组本身分配空间，并没有对数组的元素进行初始化。所以对于类类型的数值，空间分配需要经过两步。
    第一步先创建数组本身:            类型 数组名[] = new 类型[数组大小] ;
    第二步分别创建各个数组元素：     数组名[0] = new 类型(初值表);
                                    ...
                                    数组名[数组大小-1] = new 类型(初值表);
    若有Point类定义如下:
    class Point {
      int x, y;
      Point(int x1, int y1) {
        x = x1;
        y = y1;
      }
      Point() {
        this(0 , 0);
      }
    }
    语句points = new Point[100]; 只创建了有100个Point型变量的数组。它没有创建100个Point对象。因为Point型是类类型。这些对象必须再单独创建，如：points[0] = new Point();  points[n] = new Point();
    数组变量的类型可以不同于所指向的数组类，但应该是它的祖先类。例如:
    Object[] points;
    points - new Point[100]; // 这是允许的
    points是Object类型的数组，第二行创建的数组是Point类型的，Point派生于公共父类Object。
    反之则是不允许的，例如：
    Point[] points;
    points = new Object[100]; // 不允许的

  3.访问数组元素：
    在Java中，数组下标从0开始，数组中的元素个数length是数组类中唯一的数据成员变量。使用new创建数组时系统自动给length赋值。数组一旦创建完毕，其大小就固定下来。程序运行时可以使用length进行数组边界检查。如发生越界访问，则抛出一个异常，
    在循环中使用length就不会引起数组下标越界，修改也更加方便。当定义了一个数组，并用运算符new为它分配了内存空间后，就可以引用数组中的每一个元素了。数组名加上下标可以表示数组元素，元素的引用格式为：数组名[下标] 其中，下标的范围是 0 ~ length-1。下标可以是整型常量或表达式。
    当创建一个数组时，每个元素都被初始化。如前面创建的字符数组s，它的每个值被初始化为0(\0000)。而数组points的每个值被初始化为null，表明它尚未指向真正的Point对象。在执行赋值语句: points[0] = new Point();后，系统创建一个真正的Point对象，并让数组的第一个元素指向它。
    注意，包括数组元素在内的所有变量的初始化，从系统安全角度看都是必不可少的，任何变量都不能在没有初始化的状态下使用。但不幸的是，编译器不能检查数组元素的初始化情况，所以需要程序员自己多加注意。
  
  4.多维数组
    4.1多维数组的定义：
     数组元素可以声明为任何类型，比如一维数组类型，这样可以建立数组的数组，即二维数组。推而广之，可以得到多维数组。一般来讲，n维数组是n-1维数组的数组。声明多维数组时使用类型及多对方括号。例如,int[][]是类型，表示二维数组，每个元素都是int类型。
     以二维数组为例，定义格式如下：
     类型 数组名[][];
     例如：int intArray[][]; 声明了二维数组intArray。
     也可采用另外两种定义方式。
     类型[][] 数组名;
     类型[] 数组名[];
     与一维数组一样，二维数组定义时对数组元素没有分配内存空间，同样要进行初始化后，才可以访问每个元素。

    4.2多维数组的初始化：
     与一维数组一样，多维数组的初始化也分为静态和动态两种。静态初始化时，在定义数组的同时为数组元素赋初值。例如二维数组intArray的初始化如：int intArray[][] = {{1,3} , {5,7}};
     这里，不必指出数组每个维的大小，系统会根据初始化时给出的初值的个数自动计算数组每个维的大小。外层括号所含各元素是数组第一维的各元素，内层括号对应于数组第二维的元素。上面这个intArray数组是一个[2][2]的数组。
     使用两个下标可以访问数组中的对应元素，如intArray[1][1]表示该数组第二行第二列的元素，它的值为7。注意，数组各维的下标均从0开始。
     对二维数组进行动态初始化时，有两种分配内存空间的方法：直接分配与按维分配。直接分配就是直接为每个维分配空间，声明数组时，给出各维的大小。仍以二维数组为例，格式如下：
     类型 数组名[][] = new 类型[数组第一维大小][数组第二维大小];
     例如：int intArray[][] = new int[2][3];声明了一个2行3列的二维数组。
     按维分配是从最高维起(而且必须从最高维开始),分别为每一维分配内存，创建二维数组的格式如下：
     类型 数组名[][] = new 类型[数组第一维大小][];
     数组名[0] = new 类型[数组第二维大小];
     数组名[1] = new 类型[数组第二维大小];
      ...
     数组名[数组第一维大小-1] = new 类型[数组第二维大小];
     如果创建数组时第二维大小是一样的，则创建的是一个矩阵数组。如下：
     int twoDim[][] = new int[4][];  // 创建一个4行的二维数组
     twoDim[0] = new int[5]; // 第一行有5列
     twoDim[1] = new int[5]; // 第二行有5列
     twoDim[2] = new int[5]; // 第三行有5列
     twoDim[3] = new int[5]; // 第四行有5列
     第一行的声明语句调用new创建了一个数组对象，且说明了第一维的大小(4)，此时数组的4个元素中各含有一个null引用。后续的4个声明语句分别让这4个元素指向各含5个元素的一维数组，由此构成了一个4行5列的二维数组。
     直接分配与按维分配的含义是相同的。例如：
     int matrix[][] = new int[4][5];
     等价于下面这段代码。
     int matrix[][] = new int[4][];
     for(int j = 0; j < matrix.length; j++) 
        matrix[j] = new int[5];
     虽然数组声明格式允许方括号在变量名的左面或右面使用，但在多维数组中使用时应注意其合法性。正确的及错误的二维数组声明如下：
     这是正确的：
     int a1[][] = new int[2][3];
     int a2[][] = new int[2][];
     int []a3[] = new int[4][6];
     下面是错误的：
     int errarr1[2][3]; // 不允许声明静态数组
     int errarr2[][] = new int[][4]; // 维度声明顺序应从高维到低维，先说明高维，在说明低维
     int errarr3[][4] = new int[3][4]; // 数组维度的指定只能出现在new运算符之后

    4.3多维数组的引用：
     在定义并初始化多维数组后，可以使用多维数组中的每个元素。仍以二维数组为例，引用方式为：数组名[第一维下标][第二维下标]
     数组下标也称为索引，它们都可以是整型常数和表达式，都是从0开始。第一维也称为行，第二维也称为列。例如，声明了数组myTable: int myTable[][] = new int[4][3];
     如果要访问myTable的元素，只需要指定相应的行、列下标就可以了。
     myTable[0][0] = 34;
     myTable[0][1] = 15;
     myTable[0][2] = 3 * myTable[0][1] + 11;
     二维数组也有length属性，但它只表示第一维的长度。例如：int ages[4][7]; 则ages.length的值为4，而不是28。
     可以分别存取每个维的长度，例如：
     int[][] ages = new int[4][7];
     int[] firstArray = ages[0]; // first.length = 7
     在Java中，数组是用来表示一组同类型数据的数据结构，并且数组是定长的，初始化后，数组的大小不会再动态变化。数组变量是一个指向数组对象实例的引用。
     数组创建后就不能再改变它的大小，但是可以使用同一个引用变量指向另一个全新的数组，例如: 
     int elements[] = new int[6];
     elements = new int[10];
     执行这两行语句后,elements指向第二个数组，第一个数组实际上丢失了，除非还有其他的引用指向它。
     可以使用一种高效率的方法复制数组。System类中提供了一个特殊的方法arraycopy()，它可以将一个数组中的元素复制到另一个数组中。arraycopy()方法的声明如下：
      public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
     其中，src表示源数组，srcPos表示源数组中的起始位置，dest表示目标数组，destPos表示目标数组中的起始位置，length表示要复制的数组元素的个数。
      例如，下面的代码将数组src中的前5个元素复制到数组dest中。
      int src[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
      int dest[] = {10, 11, 12, 13, 14, 15, 16, 17, 18};
      System.arraycopy(src, 0, dest, 0, 5);
      System.out.println("dest数组中的各个元素为：");
      for (int i = 0; i < dest.length; i++) {
         System.out.print(dest[i] + " ");
      }
      运行结果为：
      dest数组中的各个元素为：
      1 2 3 4 5 15 16 17 18
      从上面的运行结果可以看出，arraycopy()方法将src数组中的前5个元素复制到dest数组中，而dest数组中原来的前5个元素被覆盖了。

第二节、字符串类型：
  字符串是由有限个字符组成的序列，Java中的字符串是一个对象，而不是一个以'\0'结尾的字符数组。Java的标准包java.lang中封装了String类和StringBuffer类，其中String类是不可变的，而StringBuffer类是可变的。
  1.字符串的声明：
    字符串是内存中连续排列的0个或多个字符。不变字符串是指字符串一旦创建，其内容就不能改变。比如，对String类的实例进行查找、比较、连接等操作时，既不能输入新字符，又不能改变字符串的长度。对于那些需要改变内容并有许多操作的字符串，应该使用StringBuffer类。
    String类和StringBuffer类中都封装了许多方法，用来对字符串进行操作。
    Java程序中的字符串分为常量和变量两种，其中字符串常量使用双引号括起来的一串字符。系统为程序中出现的字符串常量自动创建一个String对象，例如：System.out.println("Hello World!"); 将创建"Hello World!"对象，这个创建过程是隐含的。
    对于字符串变量，在使用之前要显式声明，并进行初始化。字符串的声明很简单，例如：String s1;  StringBuffer sb1;
    也可以创建一个空的字符串：
    String s1 = new String();
    StringBuffer sb1 = new StringBuffer();
    此外，还可以由字符数组创建字符串，如右所示：char chars[] = {'a', 'b', 'c', 'd', 'e'};  String s2 = new String(chars);
    当然，可以直接用字符串常量来初始化一个字符串：String s3 = "Hello World!";
    StringBuffer类不能使用字符串常量来创建，比如：StringBuffer sb2 = "Hello World!"; 是错误的。但是可以使用String类的变量来创建，比如使用已经定义的s3来创建一个StringBuffer对象：StringBuffer strb3 = new StringBuffer(s3);

  2.字符串的操作：
    字符串创建之后，可以使用字符串类中的方法对它进行操作。
    String类的对象实例是不可改变的，一旦创建就确定下来。对字符串施加操作后并不改变字符串本身，而是又生成了另一个实例。
    StringBuffer类处理可变字符串，当修改一个StringBuffer类的字符串时，不是再创建一个新的字符串对象，而是直接操作原字符串。Java为两个类提供的方法不完全相同。
    String类和StringBuffer类中共有的常用方法如下：
     (1)、length(): 返回字符串的长度。  
     (2)、charAt(int index): 返回字符串中index位置的字符。
     (3)、subString(int beginIndex): 截取当前字符串中从beginIndex开始到末尾的子串。
    String类中常用的方法如下：
     (1)、replace(char oldChar, char newChar): 将当前字符串中出现的所有oldChar转换为new Char。
     (2)、toLowerCase(): 将当前字符串中所有字符转换为小写形式。
     (3)、toUpperCase(): 将当前字符串中所有字符转换为大写形式。
     (4)、concar(String str): 将str连接在当前字符串的尾部。
     (5)、startsWith(String prefix): 测试prefix是否是当前字符串的前缀。
     (6)、trim(): 去掉字符串前面及后面的空白。
     (7)、valueOf(type value): 将type类型的参数转换为字符串形式。
    StringBuffer类中的常用方法如下：
     (1)、append(String str): 将参数str表示的字符串添加到当前串的最后。
     (2)、replace(int start, int end, String str): 使用给定的str替换从start到end之间的子串。
     (3)、capacity(): 返回当前的容量。
    String类型字符串的连接还可以使用运算符+来实现。
    系统为String类对象分配内存时，按照对象中所含字符的实际个数等量分配。而为StringBuffer类对象分配内存时，除去字符串所占空间外，再另加16个字符大小的缓冲区。对于StringBuffer类对象，length()方法获得的是字符串的长度，capacity()方法返回当前的容量，即字符串长度再加上缓冲区大小。
    String类中有多个比较方法，如compareTo()、equals()、equalsIgnoreCase()、regionMatches()等，它们用于实现字符串的比较。方法的名字反映了它们的功能，这里不再详细介绍。
    此外，Java中也可以使用关系运算符"=="判断两个字符串是否相等。与equals() 方法不同的是，"=="判定两个字符串对象是否是同一实例，即它们在内存中的存储空间是否相同。

第三节、Vector类：
  与大多数程序设计语言一样，Java的数组只能保存固定数目的元素，数组空间一经申请就不可再改变，不能再追加数组的空间。为了解决这个问题，Java中引入了Vector(向量)类，可以看作是可变数组。
  1.概述：
    Vector是Java.util包提供的一个非常重要的工具类，它类似于数组，可以使用整数下标来访问各个元素，但是比数组的功能更强大。首先，它是变长数组，Vector实例的大小可以根据需要来改变。创建了Vector的对象后，如果增加或删除了其中的元素，则Vector的大小也相应地变大或变小。
    其次，保存的元素的类型可以不一样。因此可以看作是把不同类型的元素按照动态数组进行处理。Vector类的对象不但可以保存顺序的一列数据，而且还提供了许多有用的方法来操作和处理这些数据。
    当需要处理由数目不定、类型不同的对象组成的对象序列，或是需要频繁地在对象序列中进行插入/删除/查找操作时，通常使用向量来替代数组。但要注意，Vector类的实例中只能保存对象类型，而不能是基本数据类型，例如int类型。
    Vector类包含的成员变量有3个：
      (1)、protected intcapacityIncrement:  增量的大小。如果指为0.则缓冲区的大小每次倍增。
      (2)、protected intelementCount:       Vector对象中元素的数量。
      (3)、protected ObjectelementData[]:   元素存储的数组缓冲区。
    系统内部会记录Vector类实例的容量capacity，实际保存的元素个数有elementCount来记录，这个值不能大于容量值。当有元素加入到向量时，elementCount会相应增大。
    当向量中添加的元素超过了它的容量后，向量的存储空间以容量增值capacityIncrement的大小为单位增长，为以后新的元素加入做好准备。元素保存在数组elementData中。
  
  2.Vector类的方法：
    2.1构造方法
      常用的Vector类的3个构造方法如下：
        public Vector(): 创建一个空向量。
        public Vector(initnitialCapacity): 以指定的初始存储容量initialCapacity构造一个空的向量Vector。
        public Vector(initnitialCapacity, int capacityIncrement): 以指定的初始存储容量initialCapacity和增量capacityIncrement构造一个空的向量Vector。 
      创建Vector的实例时，要指明其中保存的元素的类型。例如: Vector<String> myVector = new Vector<String>(100,50); 创建的myVector向量序列初始有100个字符串的空间，以后一旦空间用尽则以50为单位递增，使序列中能够容纳的元素个数为150，200.....
    
    2.2添加方法
      向Vector类对象中添加元素的常用方法如下：
        (1)、addElement(Object obj): 将新元素obj添加到序列尾部。
        (2)、insertElementAt(Object obj, int index): 将指定对象obj插入到指定位置index处。
        (3)、add(int index, Object obj): 在向量的指定位置index插入指定的元素obj。
    
    2.3元素的修改或删除方法：
      使用以下方法可以修改或删除Vector类对象序列中的元素：
        (1)、setElementAt(Object obj, int index): 将指定位置index处的元素设置为obj。如果下标index是负数或超出实际元素的个数，则抛出异常ArrayIndexOutOfBoundsException。
        (2)、removeElement(Object obj): 删除向量序列中第一个与指定的obj对象相同的元素，同时将后面的所有元素均向前移一个位置。这个方法返回的是一个布尔值，表示删除操作成功与否。
        (3)、removeElementAt(int index): 删除指定index位置的元素，同时将后面的所有元素均前移一个位置。如果下标index是负数或超出实际元素的个数，则抛出异常ArrayIndexOutOfBoundsException。
        (4)、removeAllElements(): 清除向量序列中的所有元素，同时向量的大小置为0。
    
    2.4元素的查找方法：
      Java还提供了在向量序列中进行查找的操作，常用的查找方法如下：
        (1)、elementAt(int index): 返回指定位置index处的元素。如果下标index是负数或超出实际元素的个数，则抛出异常ArrayIndexOutOfBoundsException。这个方法的返回值是Object类型，在使用之前通常需要进行强制类型转换，将返回的对象引用转换成Object类的某个具体子类的对象。如：String str = (String)myVector.elementAt(0);
        (2)、contains(Object obj): 检查向量序列中是否包含指定的对象元素obj。
        (3)、indexOf(Object obj, int start_indetx): 从指定的start_index位置开始向后搜索,返回所找到的第一个与指定对象obj相同的元素的下标位置。若指定的对象不存在，则返回-1;
        (4)、lastIndexOf(Object obj, int start_indetx): 从指定的start_index位置开始向前搜索，返回所找到的第一个与指定对象obj相同的元素的下标位置。若指定的对象不存在，则返回-1;
      使用Vector时，一定要先创建后使用。如果不先使用new运算符利用构造方法创建Vect类的对象，而直接使用Vector的方法，例如addElement()等方法，则可能造成堆栈溢出或使用null指针异常等。
      程序示例在MyVectorTest.java中。

第五章小结：数组和字符串都是程序设计中经常使用的数据结构。大多数语言都提供了这两种类型。Java中，数组和字符串都是对象。
本章介绍了数组的声明，静态和动态初始化数组元素的方式。通过示例介绍了如何访问数组元素。作为一个重要的补充，本章介绍了向量类，可以将它看作是变长数组类型。
本章还介绍了String类和StringBuffer类以及类中对字符串进行操作的相关方法。


第六章 继承与多态
第一节、子类：
  Java中的类层次结构为树状结构，这和自然界中描述的一个事物是类似的。例如，可以将动物划分为哺乳类动物及爬行类动物，然后又对这两类动物继续细分。
  在Java中，可以将哺乳类动物和爬行类动物作为两个类，然后再定义一个动物类，哺乳类动物和爬行类动物都是动物类的子类。这样，就形成了一个类的继承关系。子类与父类的关系是：子类对象" is a "父类对象，也就是说，子类中的任何一个成员也是父类中的一个成员。
  在Java中，使用extends关键字来表示继承关系。使用继承这一面向对象的特性，可以支持软件的可复用性，保证了代码可以在类之间共享。
  1. is a 关系：
    在程序中，有时要建立关于某对象的模型，比如说雇员Employee，然后从这个最初的模型派生出多个具体化的版本，如经理Manager。显然，一名Manager首先是一名Employee，他具有Empolyee的一般特性。此外，Manager还有Empolyee所不具有的额外特性。
    对于Employee，可能具有的属性信息包括名字、受雇时间、生日及其他相关信息等，而对于Manager，可能还具有所管理的团队等属性信息。为此，定义两个类来表示它们。
    例如：具有一般性和特殊性的两个类：
    public class Employee {                 // 具有一般性的类
      private String name, jobTitle;
      private DatehireDate, dateOfBirth;
      private int grade;
      ...
    }
    public class Manager {                 // 具有特殊性的类
      private String name, jobTitle;
      private DatehireDate, dateOfBirth;
      private int grade;                   // 以上是与Employee共有的属性
      private String department;           // 特有的属性
      private Employee[] subordinates;     // 特有的属性
      ...
    }
    从上面的定义可以看出，Manager类和Employee类之间存在重复部分。实际上，适用于Employee的很多属性和方法可以不经修改就被Manager所使用。Manager与Employee之间存在"is a"关系，即Manager "is a" Employee。
    使用 "is a" 关系要特别注意，有些对象之间虽然也是"大"与"小"的关系，但并不是一般与特殊的关系，例如汽车又包括了车身与发动机，但不能说它们之间存在"is a"关系，它们只能是整体与部分的关系，一般地称为"has a"关系。

  2. extends关键字：
    与一般的面向对象语言一样，Java提供了派生机制，允许程序员用以前已定义的类来定义一个新类。新类称作子类，原来的类称作父类，也称为基类或超类。两个类中共同的内容放到父类中，特殊的内容放到子类中。在定义类时可以表明一个类是不是另一个类的子类。
    在Java中，使用extends关键字来表示继承，格式如下：
      修饰符 class 子类名 extends 父类名 {
        类体
      }
    例如，public class A extends B 表示A类派生于B类，A类是子类，B类是父类。如果一个类的定义中没有出现extends关键字，则表明这个类派生于Object类。Java中预定义及程序员自己定义的任何类都直接或间接地继承于Object类，Object类是所有类的父类或祖先类。
    再来考虑之前的Employee类和Manager类，很明显，它们具有"is a"关系，所以可以使用派生机制来表示它们，即可以从Empolyee类派生处Manager类，现在重新定义这两个类。
      public class Employee {
        private String name, jobTitle;
        private DatehireDate, dateOfBirth;
        private int grade;
        ...
      }
      public class Manager extends Employee {     // 派生子类
        private String department;                // 只列出Employee类中没有的属性
        private Employee[] subordinates;
        ...
      }
    Manager类中有Empolyee类的所有变量和方法，所有这些变量和方法都继承于父类中的定义。子类中只是定义额外的特性，或者进行必要的修改。
    派生机制改善了程序的可维护性，增加了可靠性。对父类Employee所做的修改延伸至子类Manager类中。

  3. Object类：
    Object类是Java程序中所有类的直接或间接父类，处在类层次的最高点。所有其他的类都是从Object类派生而来的。Object类包含了所有Java类的公共属性，其构造方法是Object()。
    类中主要的方法如下：
      (1)、public final Class getClass(): 获取当前对象所属的类信息，返回Class对象。
      (2)、public String toString():  按字符串对象返回当前对象本身的有关信息。
      (3)、public boolean equals(Object obj): 比较两个对象是否是同一个对象，是则返回true。
    关于对象相等的判别，在Java中有两种方式。一种是使用==运算符，另一种是使用equals()方法。这两种方式判定的都是两个对象是否是同一个对象(称为同一)。如果两个对象具有相同的类型及相同的属性值，则称为相等。同一的对象一定相等，但相等的对象不一定同一。
    相等判别示例：
      class BankAccount {
        private String OwnerName;
        private int AccountNumber;
        private float Balance;
        BankAccount(String name, int num1, float num2) { // 构造方法
          OwnerName = name;
          AccountNumber = num1;
          Balance = num2;
        }
        String getOwnerName() {  //返回名字
          return OwnerName;
        }
        int getAccountNumber() { // 返回账号
          return AccountNumber;
        }
        float getBalance() {  // 返回余额
          return Balance;
        }
      }
      public class EqualsTest {
        public static void main(String args[]) {
          BankAccount a = new BankAccount("张三", 123456, 1000.0f);
          BankAccount b = new BankAccount("张三", 123456, 1000.0f);
          // BankAccount b = a;  // 创建b的另一种方式
          if (a.equals(b)) {
            System.out.println("equals_YES");
          } else {
            System.out.println("equals_NO");
          }
          if (a == b) {
            System.out.println("==_YES");
          } else {
            System.out.println("==_NO");
          }  
        }
      }
    输出分别是equals_NO和==_NO，即两种方式下判定的都是同一性。由于a和b是两个独立的对象，故它们不是同一的。如果对象b不是使用new操作符来创建，而是通过赋值语句b = a来创建(如上注释掉的语句)，再来判定两个对象的相等性时，会看到输出分别是equals_YES和==_YES。
    要判断两个对象各个属性域的值是否相同，不能使用从Object类继承来的equals方法，而需要在类声明种对equals方法进行覆盖，即重新修改这个方法。例如，String类种已经重写了Object类的equals方法，故可以判定两个字符串的内容是否相同。如下，在BankAccount类中添加equals方法：
    public boolean equals(Object x) {
      if(this.getClass() != x.getClass())   // 具有相同的类型
        return false;
      BankAccount b = (BankAccount)x;
      return((this.getOwnerName().equals(b.getOwnerName()))
            &&(this.getAccountNumber() == b.getAccountNumber())
            &&(this.getBalance() == b.getBalance())); // 判定各个成员变量的值是否相等
    }
    重写的equals方法判定的是对象种的值是否相等，再次运行相等判别示例，得到的输出分别是equals_YES和==_NO。即虽然不是同一个对象，但各属性的值是对应相等的。

  4. 单重继承：
    Java是完全的面向对象语言，具有完全的OOP能力。在类的继承机制中，它抛弃了多重继承功能，仅实现了单重继承机制。
    多重继承是指从多个类共同派生一个子类，即一个类可以有多个父类。多重继承关系类似于一个网。如果子类的多个父类有同名的方法和属性，那么容易造成子类实例的混乱。这是多重继承不可克服的缺点。在Java中抛弃了多重继承，只允许单重继承。虽然如此，并没有减弱Java在继承方面的能力。
    Java中提供了接口这个概念，这是一种特殊的类，多重继承的能力通过接口来实现。总之，在Java中，如果一个类有父类，则其父类只能有一个，也就是只允许从一个类中拓展类。这条限制称为单重继承。类的继承关系构成一棵树。任何一个类都是Object类的后代。
    子类可以继承父类中的方法和成员，这个行为可以拓展，也就是说，一个类可以从其所有的祖先类(在树中通往Object的路径上的类)中继承属性及行为。虽然一个子类可以从父类及祖先类中继承所有能继承的方法和成员变量，但它不能继承构造方法。
    只有两种方式能让一个类得到构造方法，一种是自己编写构造方法；另一种方式是，在用户没有编写构造方法的时候，由系统为类提供唯一一个默认的构造方法。
    子类不能直接访问其父类中定义的私有属性及方法，但可以使用父类中定义的共有(及保护)方法访问私有数据成员。

  5. 对象转型：
    和大多数面向对象的语言一样，Java允许使用对象的父类类型的一个变量指向该对象，比如对于前面定义的Employee类和Manager类，可以将子类的对象赋给父类的变量：
      Employee e = new Manager();     // 子类Manager的实例赋给父类变量e;
    这称为对象转型(Casting)。使用变量e，可以访问Employee对象的内容，而隐藏Manager对象中的特殊内容。这是因为编译器知道e是一个Employee，而不是Manager。对象引用的赋值兼容原则允许把子类的实例赋给父类的引用。但反过来是错误的，不能把父类的实例赋给子类的引用。例如：
      Manager m = new Employee();     // 错误，不能把父类的实例赋给子类的引用
    类的变量既可以指向本类实例，又可以指向其子类的实例，这表现为对象的多态性。假定类的继承关系定义如下，层次关系如：
            ________
           | Object |
            ————————
               |                           //  类层次关系
            ________                       //  public class Employee extends Object
          | Employee |                     //  public class Manager extends Employee
            ————————                       //  public class Contractor extends Employee
               |                           //  虽然extends Object的写法完全合乎语法，但由于Object是所有类的父类，因此，这种写法是多余的。在这里，这样的写法只是为了提醒读者注意类之间的层次关系。
       ———————————————————    
      |                   |
    ________           _________
   | Manager|        | Contractor|

    在程序中，有时需要判断一个引用到底指向哪个实例，这里可以通过instanceof运算符来实现。假定，Employee类型的引用指向一个对象，但分辨不清该对象是Employee类型、Manager类型还是Contractor类型。借助于instanceof，可以判定它的真正类型。
    instanceof运算符的语法如下：
      对象 instanceof 类名
    instanceof的使用示例:
    public void method(Employee e) {
      if(e instanceof Manager) {
        // 对Manager对象进行处理
      } else if(e instanceof Contractor) {
        // 对Contractor对象进行处理
      } else {
        // 对Employee对象进行处理
      }
    }
    如果用instanceof运算符已判定父类的引用指向的是子类实例，就可以转换该引用，恢复对象的全部功能。假设已有父类Employee和子类Manager:
      public static void main(String[] args) {
        Employee betty = new Manager();  //  使用父类引用指向子类实例
        betty.name = "Betty";
        System.out.println(betty.getName());
        betty.employeeNumber = 54321;
        //betty.department = "Test";   // 这里假设子类有一个department,想直接使用将发生错误
        if (betty instanceof Manager) {
          Manager m = (Manager)betty; //  将父类引用转换为子类引用
          m.department = "Test";      //  现在可以使用department了
          System.out.println("This is the manager of " + m.getDepartment());
        }
      }
    department是Manger中的属性，不是Employee中的属性，编译器知道这一点。所以当使用Employee类的引用betty来访问这个属性(betty.department)时，编译器在Employee中找不到department成员，所以会报告错误。转型后，编译器将betty看作是Manager的实例，再访问department成员时是正确的。
    一般地，进行对象引用转型时有以下规则。
      ①沿类层次向“上”转型总是合法的，例如，把Manager引用转型为Employee引用。此种方式下不需要转型运算符，只用简单的赋值语句就可以完成。
      ②对于向“下”转型，只能是祖先类转型到后代类，其他类之间是不允许的。例如，把Manager引用转型为Contractor引用是非法的，因为Contrator不是Manager。这两个类之间没有继承关系。要替换的类(赋值号右侧)必须是当前引用类型(赋值号左侧)的父类，且要使用显式转换。

第二节、方法覆盖与多态：
  使用类的继承关系，可以从已有的类产生一个新类。在原有特性基础上，增加了新的特性。父类中原有的方法可能不能满足新的需求，因此需要修改父类中已有的方法。这就是方法覆盖(override)，也称为方法重写或隐藏。
  子类中定义方法所用的名字、返回类型及参数列表和父类中方法使用的完全一样，也就是具有相同的方法签名。此时，称子类方法覆盖(重写)了父类中的方法，从逻辑上看就是子类中的成员方法将隐藏父类中的同名方法。
  1. 方法覆盖及其规则：
    在面向对象语言程序设计中，方法覆盖是经常用到的概念。通过方法覆盖，可以达到语言多态性的目的。当子类中要做的事情(某个方法)与父类中不完全相同时，就要重写父类中的相关方法。
    当子类重写父类方法时，子类与父类使用的是相同的方法名及参数列表，但可以执行不同的功能，当然子类中也可以什么都不做。利用方法隐藏机制，子类对象的操作可以与父类中定义的不完全一样，甚至是完全不一样，从而满足了灵活性的要求。要注意的是，覆盖的同名方法中，子类方法不能比父类方法的访问权限更严格。
    例如，如果父类中方法method()的访问权限是public，则子类中就不能含有private的method()，否则，会出现编译错误。
    注意，如果方法名相同，而参数列表不同，则是对方法的重载。调用重载方法时，编译器将根据参数的个数和类型，选择对应的方法执行。重载的方法属于同一个类，覆盖的方法分属于父类，子类中。
    以Employee类和Manager类中的方法为例，重写方法(例6.7)。
      public class Employee {
        String name;
        int salary;
        public String getDetails() {
          return "Name: " + name + "\n" + "Salary: " + salary;
        }
      }
      public class Manager extends Employee {
        String department;
        public String getDetails() {      // 重写
          return "Name: " + name + "\n" + "Salary: " + salary + "\n" + "Department: " + department;
        }
      }
    Employee类和Manager类中都有getDetails()方法，可以看出，它们返回的字符串不是完全相同的。
    再以方法覆盖为例，如下：
      public class Point {
        void print() {
          System.out.println("This is the superClass!");
        }
        public static void main(String args[]) {
             Point superp = new Point();
             superp.print();     // 调用父类方法，输出"This is the superClass!"
             Point3d subp = new Point3d();    // 调用子类方法，输出"This is the subClass!"
             subp.print(); 
        }
      }
      class Point3d extends Point {
        void print() {          // 重写
          System.out.println("This is the subClass!");
        }
      }
    如果子类已经重写了父类中的方法，但在子类中还想使用父类中被隐藏的方法，可以使用super关键字。
    如下是super关键字的使用示例(例6.3)：
      class SuperClass {
        void showMyPosition() {
          System.out.println("This is the superClass!");
        }
      }
      class SubClass extends SuperClass {
        void showMyPosition() {     
          System.out.println("At first I will go to superClass!");
          super.showMyPosition();   // 调用父类方法
          System.out.println("Now I hava moved to subClass!");
        }
      }
      public class SuperTest {
        public static void main(String args[]) {
          SubClass sub = new SubClass();  // 创建子类对象
          sub.showMyPosition();           // 调用子类方法
        }
      }
    使用super时，要注意两个问题。首先，使用super.method()调用父类中的方法method(),将执行父类方法中的所有操作，其中可能会包括一些原本不希望进行的操作。所以调用时要谨慎。
    其次，由继承性的机制可以知道,super.method()语句所调用的这个方法不一定实在父类中加以描述的，它也可能是父类从它的祖先类中继承来的。因此，有可能需要按继承层次关系依次向上查询才能够找的到。
    应用覆盖时必须注意以下两条重要规则。
      ①覆盖方法的允许范围不能小于原方法。
      ②覆盖方法所抛出的异常不能比原方法更多。
    以上两条规则均源于多态性和Java所具有的"类型安全性"的要求。
    重写方法的访问权限示例：
      class SuperClass {
        public void method() { /* 相关代码 */   }
      }
      class SubClass extends SuperClass {
        private void method() { /* 相关代码 */  }   // 使用private方法覆盖public方法，编译错误
      }
    由于子类SubClass中的方法method()是private类型，而它所覆盖的父类中的原方法是public类型，这是不允许的，编译后会出现错误信息。一个重写方法也不能抛出比被重写方法更多的异常事件。

  2. 调用父类的构造方法：
    出于安全性考虑，Java对于对象的初始化要求是非常严格的。比如，Java要求一个父类的对象要在子类运行前完成初始化。
    super关键字也可用在构造方法中，其功能为调用父类的构造方法。子类不能从父类继承构造方法，在子类的构造方法中调用父类的构造方法不失为一种良好的程序设计风格。
    如果在子类构造方法的定义中没有明确调用父类的构造方法，则系统在执行子类的构造方法时会自动调用父类的默认构造方法(即无参构造方法)。
    如果在子类构造方法的定义中调用了父类的构造方法，则调用语句必须出现在子类构造方法的第一行。
    例如，调用父类的构造方法：
      class Employee {
        String name;
        public Employee(String s) {  // 构造方法
          name = s;
        }
      }
      class Manager extends Employee {
        String department;
        public Manager(String s, String d) {  // 构造方法
          super(s);                           // 调用父类构造方法
          department = d;
        }
      }
    一般来讲，调用super()时参数的个数没有限制，只要其参数列表和父类中的某个构造方法的参数列表相符即可。在通常情况下，没有参数的默认构造方法常被用来初始化父类对象。当然，也可根据具体情况先择父类其他的构造方法。
    不管怎样，如果要显式调用父类的构造方法的话，super()调用必须放在子类构造方法的开头位置。比如，下列的写法是错误的。
      public Manager(String s, String d) {
        department = d;
        super(s);   // 错误，super()调用必须放在子类构造方法的开头位置
      }
    
  3. 多态
    在Java中，多态是一个重要概念。有了多态，能够允许同一条方法调用指令在不同的上下文中做不同的事情。以例6.3中定义的3个类及例6.7中重写的方法为例。Manager类与Employee类之间具有"is a"关系，Manager得到了父类Employee的所有可继承属性，包括数据成员和方法成员。
    这意味着对Employee对象合法的操作，对Manager对象也合法。两个类中都有getDetails()方法，实际上是子类覆盖了父类中的方法。现在假定声明了如下两个实例。
      Employee e = new Employee();
      Manager m = new Manager();
    此时，e.getDetails()和m.getDetails()将执行不同的代码。e.getDetails()调用的是Employee类中的getDetails()方法，而m.getDetails()调用的是Manager类中的getDetails()方法。这不难理解。
    但如果向这样创建实例：Employee e = new Manager(); 那么e.getDetails()将调用哪个方法呢？这引出对象是多态(Polymorphism)的概念。对象e可以有Manager的形式，也可以有Employee的形式。
    重载一个方法名可以看作是多态的，父子类之间直接或间接重写的方法名要由对象在运行时确定将调用哪个方法，这也是多态。
    实际上，这正是面向对象语言的一个重要特性。Java规定，这种情况下要执行的是与对象真正类型(运行时类型)相关的方法，而不是与引用类型(编译时类型)相关的方法。
    变量的静态类型是出现在声明中的类型。例如，变量e的静态类型是Employee。静态类型也称为引用类型，是在代码编译时确定下来的。运行过程中某一时刻变量指向的对象的类型称为动态类型，这是它此刻的真正类型。变量的动态类型会随运行进程而改变。本例中e的动态类型是Manager。
    调用稍后可能被覆盖的方法的这种处理方式，称为动态绑定或后绑定。动态绑定一定要到运行时才能确定要执行的方法代码。在编译过程中能确定调用方法的处理方式，称为静态绑定或前绑定。
    例6.10 多态示例
      class SuperClass {
        public void method() {
          System.out.println("SuperClass!");
        }  
      }
      class SubClass extends SuperClass {
        public void method() {           // 覆盖方法
          System.out.println("SubClass!");
        }
      }
      public class Test {
        public static void main(String args[]) {
          SuperClass sup = new SuperClass();  // 静态类型与动态类型一致
          SubClass sub = new SubClass();      // 静态类型与动态类型一致
          SuperClass sup1 = new SubClass();   // 静态类型与动态类型不一致
          super.method();                     // 调用父类方法，输出SuperClass!
          sub.method();                       // 调用子类方法，输出SubClass!
          sup1.method();                      // 调用子类方法，输出SubClass!
        }
      }
    sub1声明的类型是SuperClass，但它指向的是SubClass的实例，所以，sub1.method()调用的是实例所属类(子类)的方法而不是所声明的类(父类)的方法。

第三节、终极类与抽象类：
  Java中有一个重要的关键字final,它表示终极，既可以修饰一个类，也可也修饰类中的成员变量或成员方法。顾名思义，用这个关键字修饰的类或类成员都是不能改变的。如果一个类被定义为final，则它不能有子类；如果一个方法被定义为final，则不能被覆盖；如果一个变量被定义为final，则它的值不能被改变。
  与之相对应的是关键字abstract，它可以用于类或方法，表示抽象。使用abstract修饰的方法的方法体为空，修饰的类必须被子类继承。
  1. 终极类：
    有时一些类不能被继承。Java中预定义的类Java.lang.String就是如此。这样做的目的是为了保证如果一个方法中有一个指向String类的引用，那么它肯定就是一个真正的String类型，而不是一个已被更改的String的子类。
    另外一种情况是某个类的结构和功能已经很完整，不需要生成它的子类，这是也应该在这个类的声明中以关键字final进行修饰。被标记为final的类将不能被继承，这样的类称为终极类或终态类，其声明的格式为：
      final class 终极类名 {
        类体
      }
    例6.11 定义一个final类FinalClass，当试图派生它的子类时，会导致错误。
      final public class FinalClass {
        int memberar;
        void memberMethod() {
        System.out.println("This is a final class!");
        } 
      }
      class subFinalClass extends FinalClass {   // 错误，不能继承终极类
        int memberar;
        void memberMethod() {
          System.out.println("This is a sub final class!");
        }
      }

  2. 终极方法：
    成员方法也可被标记为final，从而成为终极方法或终态方法。被标记为final的方法将不能被覆盖，从而可以确保被调用的方法是最原始的方法，而不是已被更改的子类中的方法。另外，把方法标记为final有时也被用于优化，从而提高编译运行效率。终极方法的定义格式为：
      final 返回类型 方法名(参数表) {
        方法体
      }
    例6.12 定义一个final方法，当试图在子类中覆盖它时，会导致错误。
      class FinalMethod {
        final void method() {
          System.out.println("This is a final method!");
        }
      }
      class subFinalMethod extends FinalMethod {
        void method() {   // 错误，不能覆盖终极方法
          System.out.println("This is a sub final method!");
        }
      }
    
  3. 终极变量：
    一个变量被标记为final，称为终极变量或终态变量。实际上它会成为一个常量。企图改变终极变量的值将引起编译错误。
    例6.13 不能改变终极变量的值：
      class Const {
        final float PI = 3.14f;     // 终极变量
        final String language = "Java";
      }
      public class UseConst {
        public static void main(String args[]) {
          Const c = new Const();
          c.PI = 3.1415926f;         // 错误，不能改变终极变量的值
        }
      }
    当程序中需要使用一些特殊用途的常量时，可以将它们定义在一个类中，其他的类通过引入该类来直接使用这些常量。这样可以保证常量使用的统一，并为修改提供了方便。
    如果将一个引用类型的变量标记为final，那么这个变量将不能再指向其他对象，但它所指对象中的属性值还是可以改变的。
    例6.14 终极引用的使用示例： 
      class Car {
        int number = 123;
      }
      Class FinalVariable {
        public static void main(String agrs[]) {
          final Car mycar = new Car();   // 终极引用
          mycar.number = 456;            // 可以，修改的是mycar指向的内存中的值
          mycar = new Car();             // 错误，不能修改mycar本身的值
        }
      }
    在这里，改变变量mycar的成员变量number的值是可以的，但如果试图用mycar指向其他对象就会引起错误。
  
  4. 抽象类：
    在程序设计过程中，有时需要创建某个类代表一些基本行为，并为其规范定义一些方法，但是又无法或不宜在这个类中就对这些行为加以具体实现，而希望在其子类中根据实际情况再去实现这些方法。
    例如，设计一个名为Drawing的类，它代表了不同绘图工具的绘图方法，但这些方法必须以平台无关的方法实现。很显然，在使用一台机器的硬件的同时，又要做到平台无关是不太可能的。因此解决的方法是，在这个类中只定义应该存在什么方法，而具体实现这些方法的工作由依赖于具体平台的子类去完成。
    像Drawing类这种定义了方法但没有定义具体实现的类称为抽象类。在Java中可以通过关键字abstract把一个类定义为抽象类，每一个未被定义具体实现的方法也应标记为abstract，这样的方法称为抽象方法。
    与一般的父类一样，在抽象类中可以包括被它的所有子类共享的公共行为，以及被它的所有子类共享的公共属性。在程序中不能用抽象类作为模板来创建对象，必须生成抽象类的一个非抽象的子类后才能创建实例。
    抽象类可以包含常规类能够包含的任何成员方法，因为子类可能需要继承这些方法。当然抽象类中也可包含构造方法。
    抽象类中通常会包含抽象方法，这种方法只有方法的声明，而没有方法的实现。这些方法将在抽象类的子类中被实现。除了抽象方法，抽象类中也可以包含非抽象方法，反之，不能在非抽象的类中定义抽象方法。也就是说，只有抽象类才能具有抽象方法。
    如果一个抽象类除了抽象方法外什么都没有，则使用接口更合适。
      抽象类和抽象方法的定义格式如下：
        public abstract class 抽象类名 {
            类体
        }
        public abstract 返回值类型 抽象方法名(参数列表); // 抽象方法
    例6.15 抽象类示例：
      abstract class Employee {
        int basic = 2000;
        abstract void salary();   // 抽象方法
      }
      class Manager extends Employee {
          void salary() {                             // 子类中的实现
          System.out.println("薪资等于:  " + basic * 5);
        }
      }
      class Works extends Employee {
        void salary() {                               // 子类中的实现
          System.out.println("薪资等于:  " + basic * 2);
        }
      }
    例6.16 抽象类示例：
      abstract class ObjectStorage {
        int objectnum = 0;
        Object storage[] = new Object[100];
        abstract void put(Object o);      // 抽象方法，没有方法体
        abstract Object get();           // 抽象方法
      }
      class Stack extends ObjectStorage {
        private int point = 0;
        public void put(Object o) {           
          storage[point++] = o;
          objectnum++;
        }
        public Object get() {                 // 实现不同
          objectnum--;
          return storage[--point];
        }
      }
      class Queue extends ObjectStorage {
        private int top = 0, bottom = 0;
        public void put(Object o) {           
          storage[top++] = o;
          objectnum++;
        }
        Object get() {                 // 实现不同
          objectnum--;
          return storage[bottom++];
        }
      }
    在这里，ObjectStorage类定义的是一般化的存储结构，其中包括成员变量objectnum和storage，分别用来记录存入的元素个数及元素本身。
    两个成员方法put()和get()只用来说明对于这样的存储结构应该具有存入和取出这两种基本操作，但是对于这两种操作的具体实现则依赖于具体的存储结构，因此，这两个方法被定义为抽象方法。相应地，ObjectStorage类也就成为抽象类，不论是类还是方法都要用关键字abstract进行修饰。
    抽象类的子类所继承的抽象方法同样还是抽象方法，除非提供了其父类中所有抽象方法的实现代码，否则子类还是抽象类。具体到本例，在ObjectStorage类的子类中，只有实现了put()和get()方法，这个子类才不是抽象类。
    一个抽象类中可以包含非抽象方法和成员变量。更明确地说，包含抽象方法的类一定是抽象类，但抽象类中的方法不一定都是抽象方法。
    抽象类是不能创建对象的，除非通过间接的方法来创建其子类的对象，但是可以定义一个抽象类的引用变量。也就是说，程序中形如new ObjectStorage()的表示是错误的，但如果子类Stack不再是抽象类，则这个语句就是正确: ObjectStorage obst = new Stack()。

第四节、接口
  接口是体现抽象类功能的另一种方式，可将其想象为一个“纯”的抽象类。它允许创建者规定一个类的基本形式，包括方法名、参数列表以及返回值类型，但不规定方法体。因此在接口中所有的方法都是抽象方法，都没有方法体。从这个角度上讲，可以把接口看成是特殊的抽象类，接口与抽象类都用来定义多个类的共同属性。
  接口还可以实现与抽象类不同的功能。具体来说，Java不支持多重继承的概念，一个类只能从唯一的一个类继承而来。但是，这并不意味着Java不能实现多重继承的功能。具体来说，Java允许一个类实现多个接口，从而实现了多重继承的能力，并具有更清晰的结构。
  1. 接口的定义：
    接口的定义格式为：
      [接口修饰符] interface 接口名 [extends 父接口列表] {
        // 方法原型或静态变量
      }
    接口与一般类一样，本身也具有数据成员变量与方法，但数据成员变量一定要赋初值，且此值不能再更改，而方法必须是“抽象方法”。
    仿照例6.16，例3.17使用接口的方式重写定义了一个存储字符的数据结构。
    例6.17 接口的定义： 
      interface CharStorage {   // 使用interface说明
        void put(char c);      // 抽象方法，没有方法体
        char get();            // 抽象方法
      }
    这个接口仅仅说明了一种数据存储结构中存在存入(put)和取出get()这样两种操作，并没有涉及具体实现。在应用时，还需要根据具体的存储结构来实现。
    在接口中定义的成员变量都默认为终极静态变量，即系统会将其自动添加final和static这两个关键字，并且对该变量必须设置初值。

  2. 接口的实现：
    接口的实现与类的继承是相似的，不过，实现接口的类不能从该接口的定义中继承任何行为。在实现该接口的类的任何对象中，都能够调用这个接口中定义的方法。一个类可以同时实现多个接口。
    要实现接口，可以在类的声明中用关键字implements来表示。接口中的所有抽象方法必须在类或子类中实现。implements语句的格式如下：
      class Stack implements CharStorage {
        private char mem[] = new char[10];
        private int point = 0;
        public void put(char c) {
          mem[point] = c;
          point++;
        }
        public char get() {
          point--;
          return mem[point];
        }
      }
    例6.19 接口的实现：
      public interface Insurable {      // 定义接口
        public int getPolicyNUmber();   // 抽象方法
        public int getCoverageAmount();
        public double calculatePremium();
        public Date getExpiryDate();
      }
      public class Car implements Insurable {         // 接口的实现
        public int getPolicyNumber() { ... }          // 获取保险单号的代码  
        public double calculatePremium() { ... }      // 计算保费的代码
        public Date getExpiryDate() { ... }           // 获取保险到期日的代码
        public int getCoverageAmount() { ... }        // 获取投保金额的代码
      }
    Java程序中，可以在implements后面声明多个接口名，也就是一个类可以实现多个接口。接口实际上就是一个特殊的抽象类，同时实现多个接口也就意味着具有多重继承的能力。
    由于在接口中的方法多是抽象方法，并不包含任何的具体代码，对这些抽象方法的实现都在具体的类中完成，因此，即使不同的接口中有同名的方法，类的实例也不会混淆。这正是Java取消了显式的多重机制，但还保留了多重继承的能力之所在。
    例如，在AWT事件处理中要经常用到接口。下面语句定义的类将实现所有鼠标事件的接口。
      public class MouseEventClass implements MouseListener, MouseMotionListener {
        ... // 所有方法的实现
      }
    如果查询Java的API文档就会发现，在MouseListener和MouseMotionListener两个接口中，分别定义了对鼠标进行各种操作时的响应。由于类MouseEventClass声明为同时实现这两个接口，因此，在实现时，该类一定要实现这两个接口中的所有方法，否则必须用abstract继续声明为抽象类。
    在实际应用中，并非接口里的所有方法都需要用到。这时有一个简单的方法，即用一对大括号来表示一个方法的空方法体。例如，在鼠标事件的接口(MouseListener和MouseMotionListener)中共定义了6种事件，假设程序不要求MouseUp事件进行任何响应，则代码可以写为: 
      public void MouseUp(Event e) {} // 不进行任何响应
    实现一个接口的类也必须实现此接口的父接口。
    程序6.4 是一个接口应用实例。定义一个接口Shape2D，利用它来实现对二维几何图形类Circle和Rectangle的操作。对二维的几何图形而言，面积的计算是很重要的，因此可以把计算面积的方法声明在接口里。求面积时使用的pi值是常量，可以把它声明在接口的数据成员里。
      程序6.4 接口应用示例：
        interface Shape2D {
          final double pi = 3.1415926;     // 常量
          public abstract double area();   // 抽象方法
        }
        // 定义Circle与Rectangele两个类，它们都实现了Shape2D接口
        class Circle implements Shape2D {
          double radius;
          public Circle(double r) { radius = r; }           // 构造方法
          public double area() { return pi * radius * radius; } // 计算面积
        }
        class Rectangle implements Shape2D {
          int width, height;
          public Rectangle(int w, int h) { width = w; height = h; } // 构造方法
          public double area() { return width * height; }            // 计算面积
        }
        // 定义测试类
        public class InterfaceTester {
          public static void main(String args[]) {
            Circle c = new Circle(2.0);
            System.out.println("圆的面积是：" + c.area());
            Rectangle r = new Rectangle(5, 6);
            System.out.println("矩形的面积是：" + r.area());                       
          }
        }
    在接口的定义中，Java允许省略定义数据成员的final关键字、方法的public及abstract关键字，因此程序6.4中的接口也可以是这样的的：
      interface Shape2D {
        double pi = 3.1415926;     // 数据成员一定要初始化
        double area();             // 抽象方法
      }  
    不能直接由接口来创建对象，而必须通过由实现接口的类来创建。同抽象类一样，使用接口名作为一个引用变量的类型也是允许的，既可以声明接口类型的变量(或数组)，并用它来访问对象。该引用可以用来指向任何实现了该接口的类的实例。使用时将根据动态绑定的原则，视该变量所指向的具体实例来进行操作。
    例如：
      public class VariableTester { 
        public static void main(String args[]) {
          Shape2D var1, var2;             // 接口类型的变量
          var1 = new Rectangle(5 , 6);    // 接口引用指向类的实例
          System.out.println("矩形的面积是：" + var1.area());
          var2 = new Circle(2.0);         // 接口引用指向类的实例
          System.out.println("圆的面积是：" + var2.area());
        }
      }

第六章小结：
  本章继续介绍有关面向对象的内容。介绍子类与继承、方法的覆盖和多态等概念，此外还介绍了终极类及抽象类的概念及用法。接口也是重要的概念，是实现多重继承的唯一途径，本章也介绍了接口及类实现接口的方式。
  本章的内容是面向对象程序设计的精髓所在，要能使用extends关键字声明子类，能够正确进行对象转型。要能够区分方法覆盖于方法重载，能够掌握调用本类及父类中的方法、覆盖父类中的方法，从而全面掌握多态的概念。


第七章、输入和输出流
第一节、数据流的基本概念：
  几乎所有的程序都离不开信息的输入和输出，比如从键盘读取数据，从文件中获取或者向文件存入数据，在显示器上显示数据。这些情况下都会涉及有关输入/输出的处理。在Java中，把这些不同类型的输入、输出源抽象为流(Stream)，其中输入或输出的数据称为数据流(Data Stream),用统一的接口来表示。
  数据流是指一组有顺序的、有起点和终点的字节集合。程序从键盘接收数据或向文件中写数据，都可以使用数据流来完成。
  流被组织成不同的层次，数据流分为输入数据流和输出数据流。输入数据流只能读不能写，而输出数据流只能写不能读。从数据流中读取数据时，必须有一个数据源与该数据流相连。
  Java.io包中提供了表示数据流的4个基本抽象类，分别是InputStream、OutputStream、Reader和Writer。此外，包中还有其他常用的数据流，因此在涉及数据流操作的程序中，几乎都要使用引入语句：import java.io.*; 才能够使用这些由环境本身提供的数据流类。
  最初的版本中，Java.io包中的流只有普通的字节流，即以byte为基本处理单位的流。字节流用来读写8位的数据，由于不会对数据作任何转换，因此可以用来处理二进制的数据。在后来的版本中，java.io包中又加入了专门用于字符流处理的类，这是以Reader和Writer为基础派生的一系列的类。

  1. 输入数据流：
    输入数据流是指只能读不能写的数据流，用于向计算机内输入信息使用。
    java.io包中所有输入数据流都是从抽象类InputStream继承而来，并且实现了其中所有的方法，包括读取数据、标记位置、重置读写指针、获取数据量等。从数据流中读取数据时，必须有一个数据源与该数据流相连。
    输入数据流中提供的主要数据操作方法如下：
      ①int read(): 从输入流中读取一个字节的二进制数据。
      ②int read(byte[] b):  将多个字节读到数组中，填满整个数组。
      ③int read(byte[] b, int off, int len):  从输入流中读取长度为len的数据，从数组b中下标为off的位置开始放置读入的数据，读毕后返回读取的字节数。
    这三个方法提供了访问数据流中数据的方法，所读取的数据都默认为字节类型。第一个read()方法将读取的一个字节作为低位，形成一个0~255的int类型的数值返回。它是一个抽象方法，需要在子类中具体实现。
    以上3个方法中，当输入流读取结束时，会得到-1，以标志数据流的结束。在实际应用中，为提高效率，读取数据时经常以系统允许的最大数据块长度为单位读取。也就是说要与一个后面即将讨论的BufferInputStream相连。
      ④void close(): 关闭数据流。
    当结束对一个数据流的操作时应该将其关闭，同时释放与该数据流相关的资源，因为Java提供系统级的垃圾自动回收功能，所以当一个流对象不再使用时，系统可以自动关闭。但是，为提高程序的安全性和可读性，建议显式关闭输入/输出流。
      ⑤int available(): 返回目前可以从数据流中读取的字节数。(但实际的读操作所读得的字节数可能大于该返回值)。
      ⑥long skip(long 1): 跳过数据流中指定数量的字节不读取，返回值表示实际跳过的字节数。
    对数据流中字节的读取通常是按从头到尾顺序进行的，如果需要以反方向读取，则需要使用回推(Push Back)操作。在支持回推操作的数据流中经常用到如下几个方法：
      ⑦boolean markSupported(): 用于测试数据流是否支持回推操作，当一个数据流支持mark()和reset()方法时返回true，否则返回false。
      ⑧void mark(intmarkarea): 用于标记数据流的当前位置，并划出一个缓冲区，其大小至少为指定参数的大小。
      ⑨void reset(): 将输入流重新定位到对此流最后调用mark方法时的位置。
    
  2. 输出数据流：
    输出数据流是指只能写不能读的流，用于从计算机中输出数据。
    与输入流类似，java.io包中所有输出数据流大多是从抽象类OutputStream继承而来的，并且实现了其中的所有方法，这些方法主要提供了关于数据输出方面的支持。
    输出数据流中提供的主要数据操作方法发如下：
      ①void write(int i): 将字节i写入到数据流中，它只输出所读入参数的最低8位。该方法时抽象方法，需要在其输出流子类中加以实现，然后才能使用。
      ②void write(byte b[]): 将数组b[]中的全部b.length个字节写入数据流。
      ③void write(byte b[], int off, int len): 将数组b[]中从下标off开始的len个字节写入数据流。元素b[off]是此操作写入的第一个字节，b[off+len-1]是此操作写入的最后一个字节。
    以上这些方法用于向输出数据流中写数据。在实际应用中，和操作输入流一样，通常以系统允许的最大数据块长度为单位进行写操作。
      ④void close(): 当结束对输出数据流的操作时应该将其关闭。
      ⑤void flush(): 刷新此输出流并强制写出所有缓冲的输出字节。
    在目前通用的存储介质中内存访问的速度是最快的，因此，为加快数据传输速度，提高数据输出效率，有时输出数据流会在提交数据之前把所要输出的数据先暂时保存在内存缓冲区中，然后成批进行输出，每次传输过程都以某特定数据长度为单位进行传输。
    在这种方式下，数据的末尾一般都会有一部分数据由于数量不够一个批次，而存留在缓冲区里，调用方法flush()可以将这部分数据强制提交。
    
第二节、基本字节数据流类：
  InputStream和OutputStream两个类都是抽象类。抽象类时不能进行实例化的，因此，在实际应用中经常用到的并不是这两个类，而是一系列基本数据流类。它们都是InputStream和OutputStream的子类。在实现其父类方法的同时又定义了其特有的功能。
  1. 文件数据流：
    文件数据流包括FileInputStream和FileOutputStream，这两个类用来进行文件的I/O处理，其数据源或数据终点都应当是文件。通过所提供的方法可以对本机上的文件进行操作，但是不支持方法mark()和reset()。在构造文件数据流时可以直接给出文件名。
    例7.1 文件数据流示例：
      FileInputStream fis = new FileInputStream("a.txt");
    这样，便把文件a.txt作为该数据流的数据源。
    同样可以使用FileOutputStream向文件中输出字节。
    使用文件数据流进行I/O操作时，对于FileInputStream类的实例对象，如果所指定的文件不存在，则产生FileNotFoundException异常。由于它是非运行时异常，因此必须加以捕获或声明。对于FileOutputStream类的实例对象，如果指定的文件不存在，则系统会创建一个新文件；如果存在，那么新写入的内容将会覆盖原有数据。
    如果在读、写文件或生成新文件时发生错误，则会产生IOException异常，也需要由程序员捕获并处理。
    例7.1 文件数据流示例：
      import java.io.*;
      public class Test{
        public static void main(String[] args) {
          try {  
            FileOutputStream out = new FileOutputStream("myFile.dat");
            out.write('A');
            out.write('B');
            out.close();
          } catch (FileNotFoundException e) {
            System.out.println("找不到文件");
          } catch (IOException e) {
            System.out.println("文件写入错误");
          }
        }  
      }
    可以使用FileInputStream来读取FileOutputStream输出的数据。
    例7.2 读写示例：
      import java.io.*;
      public class Test{
        public static void main(String[] args) {
          try {
            FileInputStream in = new FileInputStream("myFile.dat");
            while(in.available() > 0)
              System.out.print(in.read() + " ");
            in.close();
          } catch(FileNotFoundException e) {
            System.out.println("Error: Cannot open file for reading. ");
          } catch(EOFEXception e) {
            System.out.println("Error: EOF encountered,file may be corrupted. ");
          } catch(IOException e) {
            System.out.println("Error: Cannot read from file. ");
          }
        }
      }
  
  2. 过滤器数据流：
    本小节介绍另外一种数据流，即过滤器(filter)。一个过滤器数据流在创建时与一个已经存在的数据流相连，这样在从这样的数据流中读取数据时，它提供的是对一个原始输入数据流的内容进行了特定处理的数据。
    2.1 缓冲区数据流：
      缓冲区数据流由BufferedInputStream和BufferOutputStream，它们是在数据流上增加了一个缓冲区，都属于过滤器数据流。当读写数据时，数据以块为单位先进入缓冲区(块的大小可以进行设置)，其后的读写操作则作用于缓冲区。
      采用这个办法可以降低不同硬件设备之间速度的差异，提高I/O操作的效率。与此同时，这两个流还提供了对mark()、reset()和skip()等方法的支持。
      在创建该类的实例对象时，可以使用两种方法，一种是使用默认缓冲区的大小，例如：
        FileInputStream fis = new FileInputStream("myFile");
        InputStream is = new BufferedInputStream(fis);
        FileOutputStream fos = new FileOutputStream("myFile");
        OutputStream os = new BufferedOutputStream(fos);
      另一种是自行设置缓冲区的大小，例如：
        FileInputStream fis = new FileInputStream("myFile");
        InputStream is = new BufferedInputStream(fis, 1024);
        FileOutputStream fos = new FileOutputStream("myFile");
        OutputStream os = new BufferedOutputStream(fos, 1024);
      一般在关闭一个缓冲区输出流之前，应先使用flush()方法，强制输出剩余数据，以确保缓冲区内的所有数据全部写入输出流。
    
    2.2 数据数据流：
      在前面提到的数据流中处理的数据都是指字节或字节数组，这是进行数据传输时系统默认的数据类型。但实际上所处理的数据并非只有这两种类型，遇到这种情况时就应用一种专门的数据流来处理。
      DataInputStream和DataOutputStream就是这样的两个过滤器数据流，它们允许通过数据流来读写Java基本类型，包括布尔型(boolean)、浮点型(float)等。假设is和os分别是前面已经建好的输入/输出数据流对象，则数据流的创建方式如下。
        DataInputStream dis = new DataInputStream(is);
        DataOutputStream dos = new DataOutputStream(os);
      在这两个类中之所以能够对这些基本类型进行操作，是因为它们提供了一组特定的方法来操作不同的基本类型。例如，在DataInputStream类中，提供了如下一些方法。
        ①byte readByte()
        ②long readLong()
        ③double readDouble()
        ④boolean readBoolean()
        ⑤String readUTF()
        ⑥int readInt()
        ⑦float readFloat()
        ⑧short readShort()
        ⑨char readChar()
      从方法名字就可以判断出，上述方法分别对byte、long、double和boolean等类型进行读取。
      相应的，在DataOutputStream类中提供了如下的方法。
        ①void writeByte(int b)
        ②void writeLong(long l)
        ③void writeDouble(double d)
        ④void writeBoolean(boolean b)
        ⑤void writeUTF(String str)
        ⑥void writeInt(int i)
        ⑦void writeFloat(float f)
        ⑧void writeShort(short s)
        ⑨void writeChar(char c)
      同样地，上述方法分别对byte、long、double和boolean等类型进行写入。
      可以看出DataInputStream的方法与DataOutputStream的方法都是成对出现的。
      如果查询API文档，就会发现在这两个数据流中也都定义了对字符串进行读写的方法，但是，由于字符编码的原因，应该避免使用这些方法。后面将要讲到Reader和Writer重载了这两个方法，当对字符串进行操作时应该使用Reader和Writer两个系列类中的方法。

  3. 对象流
    Java中的数据流不仅能对基本数据类型的数据进行操作，而且也提供了把对象写入文件数据流或文件数据流中读出的功能，这一功能是通过java.io包中的ObjectInputStream和ObjectOutputStream两个类来实现的。能够输入/输出对象的流称为对象流。
    3.1 写对象数据流：
      例7.2中的代码段将一个java.util.Date对象实例写入文件。
      例7.2 对象流示例：
        Date d = new Date();             // 一个对象d
        FileOutputStream f = new FileOutputStream("date.ser");
        ObjectOutputStream s = new ObjectOutputStream(f); // 输出文件
        try {
          s.writeObject(d);
          s.close();                    // 将对象d写入文件，关闭文件
        } catch(IOException) {
          e.printStackTrace();
        }
      
    3.2 读对象数据流：
      读对象和写对象一样简单，但是要注意，方法readObject()把数据流以Object类型返回，返回内容应该在转换为正确的类名之后再执行该类的方法。
      例7.3 对象流示例： 
        Date d = null;                  
        FileInputStream f = new FileInputStream("date.ser");
        ObjectInputStream s = new ObjectInputStream(f); // 输入文件
        try {
          d = (Date)s.readObject();      // 读取对象
          s.close();                     // 关闭文件
        } catch(IOException e) {
          e.printStackTrace();
        }
        System.out.println("Date serialized at " + d); 
    
  4. 序列化：
    4.1 序列化的概念：
      能够记录自己的状态以便将来得到复原的能力，称为对象的持久性(Persistence)。称一个对象是可持久的，意味着可以把这个对象存入磁盘，磁带，或传入另一台计算机保存在它的内存或磁盘中。也就是说，把对象存为某种永久存储类型。
      对象通过数值来描述自己的状态，记录对象也就是记录下这些数值。把对象转换为字节序列的过程称为对象的序列化，把字节序列恢复为对象的过程称为对象的反序列化。序列化的主要任务是写出对象实例的数值。
      序列化是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。序列化时为了解决在对对象流进行读写操作时所引发的问题。
      如果变量是另一个对象的引用，则引用的对象也要序列化。这个过程是递归的，保存的结果可以看作是一个对象网。
      JDK1.1新增加了接口java.io.Serializable，并对Java虚拟机作了改动以支持将Java对象存为数据流的功能。Serializable接口中没有定义任何方法，只是作为一个标记来指示实现该接口的类可以进行序列化，而没有实现该接口的类的对象则不能长期保存其状态。
      这意味着只有实现Serializable接口的类才能被序列化。当一个类声明实现Serializable接口时，表明该类加入了对象序列化协议。在Java中，允许可序列化的对象通过对象流进行传输。
      例7.4 序列化示例：
        import java.io.*;
        public class Student implements Serializable {
          int id;
          String name;
          int age;
          String department;
          public Student(int id, String name, int age, String department) {
            this.id = id;
            this.name = name;
            this.age = age;
            this.department = department;
          }
        }
      要序列化一个对象，必须与特定的对象输出/输入流联系起来，通过对象输出流将对象状态保存下来，或是将对象保存到文件中，之后再通过对象输入流将对象状态恢复。
      该功能是通过java.io包中的ObjectOutputStream和ObjectInputStream两个类实现的。前者用writeObject()方法可以直接将对象保存到输出流中，而后者用readObject()方法可以直接从输入流中读取一个对象。
      例7.3 对象的存储示例：
        import java.io.*;
        public class Objectser implements Serializable {
          public static void main(String args[]) {
          Student stu = new Student(981036, "Li San", 16, "CSD");
          try {
            FileOutputStream fo = new FileOutputStream("data.ser");
            ObjectOutputStream so = new ObjectOutputStream(fo);
            so.writeObject(stu);
            so.close();
          } catch(Exception e) {
              System.out.println(e);
            }
          }
        }
      对象的恢复程序示例如下：
        import java.io.*;
        public class ObjectRecov implements Serializable {
          public static void main(String args[]) {
            Student stu;
            try {
              FileInputStream fi = new FileInputStream("data.ser");
              ObjectInputStream si = new ObjectInputStream(fi);
              stu = (Student)si.readObject();
              si.close();
            } catch(Exception e) {
              System.out.println(e);
            }
            System.out.println("ID: " + stu.id + "; name: " + stu.name + "; age: " + stu.age + "; dept: " + stu.department);
          }
        }

    4.2 对象结构表
      序列化只能保存对象再非静态成员变量，而不能保存在任何成员方法和静态成员变量，并且保存的只是变量的值，对于变量的任何修饰符都不能保存，访问权限(public,protected,private) 对于数据域的序列化没有影响。
      有一些对象类不具有可持久性，因为其数据的特性决定了它会经常变化，其状态只是瞬时的，这样的对象是无法保存其状态的，如Thread对象或流对象。对于这样的成员变量，必须用transient关键字标明，否则编译器会报错。任何同transient关键字标明的成员变量都不会被保存。
      另外，序列化可能涉及将对象存放到磁盘上或在网络上发送数据，这时会产生安全问题。对于一些需要保密的数据，不应保存在永久介质中，更不应简单地不加处理地保存下来，为了保证安全，应在这些变量前加上transient关键字。
      如果一个可持久化的对象中包含一个指向不可持久化元素的引用，则整个持久化操作将失败。
      当数据变量是一个对象时，该对象的数据成员也可以被持久化。对象的数据节后或结构树，包括其子对象树在内，构成了这个对象的结构表。
      如果一个对象结构表中包含了一个对不可持久化对象的引用，而这个引用已用关键字transient加以标记，则这个对象仍可被持久化。
      例7.5 真个对象的序列化：
        public class MyClass implements Serializable {
          public transient Thread myThread;
          private String customerID;
          private int total;
        }
      本例中，由于myThread域有transient修饰，所以尽管它是不可序列化元素，但其整个对象仍可序列化。类似的，如果对象的成员数据不适合进行序列化，则可以使用关键字transient以防止数据被序列化。
      例7.6 数据不被序列化：
        public class MyClass implements Serializable {
          public transient Thread myThread;
          private transient String customerID;
          private int total;
        }
      其中，尽管变量customerID是可序列化元素，但由于有transient修饰，所以，整个对象在序列化时不会对它进行序列化。

第三节、基本字符流：
  从JDK1.1开始，java.io包中加入了专门用于字符流处理的类，它们时以Reader和Writer为基础派生的一系列类。
  同InputStream和OutputStream类一样，Reader和Writer也是抽象类，只提供了一系列用于字符流处理的接口。它们的方法于InputStream和OutputStream类类似，只不过其中的参数换成了字符或字符数组。
  1.读者和写者：
    Java通过读者和写者，实现了对不同平台之间数据流中的数据进行转换。同其他程序设计语言使用ASCII字符集不同，java使用Unicode字符集来表示字符串和字符。ASCII字符集以一个字节(8bit)表示一个字符，可以认为一个字符就是一个字节(byte)。
    但Java使用的Unicode时一种大字符集，用两个字节(16bit)来表示一个字符，这时字节与字符就不再相同。为实现与其他程序语言及不同平台的交互，Java提供一种新的数据流处理方案，称作读者(Reader)和写者(Writer)。
    像数据流一样，在java.io包中有许多不同类对其进行支持，其中最重要的时InputStreamReader和OutputStreamWriter类。这两个类是字节流和读者、写者的接口，用来在字节流和字符流之间作为中介。
    使用这两个类进行字符处理时，在构造方法中应指定一定的平台规范，以便把以字节方式表示的流转换为特定平台上的字符表示。
    例如，构造方法如下所示：
      InputStreamReader(InputStream in): 默认规范
      InputStreamReader(InputStream in, String enc): 指定规范enc。
      OutputStreamWriter(OutputStream out): 默认规范
      OutputStreamWriter(OutputStream out, String enc): 指定规范enc。
    借助于这种转换系统，Java能够充分利用本地平台字符设置的灵活性，同时又可通过内部使用Unicode保留平台无关性。
    在构造一个InputStreamReader或OutputStreamWriter类时，Java还定义了16位Unicode和其他平台的特定表示方法之间的转换规则。由于目前大多使用单字节表示字符，在进行Java字符与其他平台转换时如果不进行特定声明，单纯构造一个读者或写者连接到数据流，则将字节码作为默认情况和Unicode进行转换。
    如果读取的字符流不是来自本地的，比如来自网上某处与本地编码方式不同的计算机，那么在构造字符输入流时就不能简单地使用默认编码规范，而应该指定一种统一的编码规范。在英语国家中，字节编码采用ISO8859_1协议。IOS8859_1是Latin-1编码系统映射到ASCII标准，能够在不同平台之间正确转换字符。
    此外，也可以利用已提供支持的编码形式列表中的一项来指定另一种字节编码方式。编码形式列表可以在native2ascii工具文件中找到。
    有时需要从与本地字符编码方式不同的数据源中读取输入内容。例如，从网络上一台不同类型的计算机上读取数据，这时就需要用明确的字符编码方式来构造InputStreamReader，否则，程序会把读到的字符当作本地表达方法来进行转换，这样就可能会引起错误。
    构造映射到ASCII码的标准的InputStreamReader的方法如下：
      ir = new InputStreamReader(System.in, "8859_1");
    读者提供的方法包括以下几种：
      void close()
      void mark(int readAheadLimit)
      boolean markSupported()
      int read()
      int read(char[] cbuf)
      int read(char[] cbuf, int off, int len)
      boolean ready()
      void reset()
      long skip(long n)
    写者提供的方法包括以下几种：
      void close()
      void flush()
      void write(char[] cbuf)
      void write(char[] cbuf, int off, int len)
      void write(int c)
      void write(String str)
      void write(String str, int off, int len)
    
  2.缓冲区读者和缓冲区写者：
    像其他I/O操作一样，如果格式转换以较大数据块为单位进行，那么会提高效率。为此，java.io中提供了缓冲流BufferedReader和BufferedWriter。其构造方法与BufferedInputStream和BufferedOutputStream类似。
    另外，除了read()和write()方法外，还提供了整行字符的处理方法。
      public String readLine(): BUfferedReader的方法，从输入流中读取一行字符，行结束标志为"\n"、"\r"或两者一起。
      public void newLine(): BufferedWriter的方法，向输出流中写入一个行结束标志。
    把BufferedReader或BufferedWriter正确连接到InputStreamReader或OutputStreamWriter的末尾是一个很好的方法。但是要在BuffferedWriter中使用flush()方法，以强制清空缓冲区中剩余内容，防止遗漏。
    程序7.5 缓冲区示例：
      import java.io.*;
      class FileToUnicode {
        public static void main(String args[]) {
          tyr {
            FileInputStream fis = new FileInputStream("FileToUnicode.java");
            InputStreamReader dis = new InputStreamReader(fis);
            BufferedReader reader = new BufferedReader(dis);
            String s;
            while((s = reader.readLine()) != null) {
              System.out.println("read: "+ s);
            }
            dis.close();
          } catch(IOException e) {
            System.out.println(e);
          }
        }
      }

第四节、文件的处理：
  Java提供了File类，用于处理与文件相关的操作。File对象可以用来生成与文件(及其所在的路径)或目录结构相关的对象。不同的系统可能会有不同的目录结构表示法。但使用File类可以达到与系统无关的目的，这里使用的是抽象的路径表达法。java.io.File类提供了获得文件基本信息及操作文件的一些方法。
  1.File类
    在对一个文件进行I/O操作之前，必须先获得有关这个文件的基本信息，例如，文件能不能被读取，能不能被写入，绝对路径是什么，文件长度是多少等。类java.io.File提供了获得文件基本信息及操作文件的一些工具。
    要创建一个新的File对象可以使用以下3种构造方法：
      第一种方法为
      File myFile;
      myFile = new File("mymotd");
      第二种方法为：
      myFile = new File("/", "mymotd");
      第三种方法为：
      File myDir = new File("/");
      myFile = new File(myDir, "mymotd");
    根据文件对象的具体情况，选择使用何种构造方法啊。例如，当在应用程序中只用到一个文件时，那么使用第1种构造方法最为实用；但如果使用了同一目录下的几个文件，则使用第2种或第3种构造方法更为方便。
    创建File类的对象后，可以应用其中的相关方法来获取文件的信息。
    1.1 与文件名相关的方法：
      String getName(): 获取文件名。
      String getPath(): 获取文件路径。
      String getAbsolutePath(): 获取文件的绝对路径。
      String getParent(): 获取文件的父目录。
      boolean renameTo(File dest): 重命名文件，成功则返回true，失败返回false。
    1.2 文件测定方法：
      boolean exists(): 文件对象是否存在。
      boolean canWrite(): 文件对象是否可写。
      boolean canRead(): 文件对象是否可读。
      boolean isFile(): 文件对象是否为文件。
      boolean isDirectory(): 文件对象是否为目录。
      boolean isAbsolute(): 文件对象是否为绝对路径。
    1.3 常用文件信息和方法：
      long lastModified(): 获取文件最后修改时间。
      long length(): 获取文件长度。
      boolean delete(): 删除文件对象指向的文件，成功则返回true，失败则返回false。
    以上方法的使用如下，File类方法使用示例：
      import java.io.*;
      class UseFile {
        public static void main(String args[]) {
          File f = new File("/export/home/d.java");
          System.out.println("File Name: " + f.getName());
          System.out.println("Path: " + f.getPath());
          System.out.println("Abs Path: " + f.getAbsolutePath());
          System.out.println("Parent: " + f.getParent());
          System.out.println(f.exists() ? "exists" : "does not exist");
          File newfile = new File("newfile");
          f.renameTo(newfile);
          System.out.println("\t Rename the file to : " + newfile.getName());
          newfile.delete();
          }
      }
    程序中构造了File类的对象，运用各个方法得到文件的各种属性，然后将这个文件改名，最后删除。但是要注意，对于文件名以外的其他属性，在File类中并没有提供对其进行修改的方法。
    1.4 目录工具：
      boolean mkdir(): 创建新目录。
      boolean mkdirs(): 创建新目录。
      String[] list(): 列出符合模式的文件名。
    File类同样可以用来描述一个目录，对其进行操作也与文件相同，只是不能改变目录名，也不能进行删除，但是可以按模式匹配要求列出目录中所有的文件或子目录。如果目录不存在，也可用mkdir()和mkdirs()来生成该目录。两者的区别在于用mkdirs()可以一次生成多个层次的子目录。

  2.随机访问文件：
    程序在读写文件时常常不仅要能够从头读到尾，还要能够像访问数据库那样，到一个位置读一条记录，到另一个位置读另一条记录，然后再读另一条。每次都在文件的不同位置进行读取。Java语言提供了RandomAccessFile类来处理这种类型的输入/输出。
    创建一个随机访问文件有以下两种方法供选择。
      1. 使用文件名：
        myRAFile = new RandomAccessFile(String name , String mode);
      2. 使用文件对象：
        myRAFile = new RandomAccessFile(File file, String mode);
    参数mode决定是以只读方式("r")还是以读写方法("rw")访问文件。例如，可以打开一个数据库进行更新：
      RandomAccessFile myRAFile;
      myRAFile = new RandomAccessFile("db/stock.dbf", "rw");
    对象RandomAccessFile读写信息的方法同数据输入/输出对象的方法相同，它可以访问DatainputStream和DataOutputStream类中的所有read()和write()方法。
    Java语言提供了移动文件读写指针的几个方法。
      long getFilePointer(): 返回文件指针的当前位置。
      void seek(long pos): 将文件指针置于指定的绝对位置。位置值以从文件开始处的字节偏移量pos来计算，pos为0的代表文件的开始。
      long length(): 返回文件的长度。位置值为length()，代表文件的结尾。
    为文件添加信息时可以利用随机访问文件来完成文件输出的添加模式。例如：
      myRAFile = new RandomAccessFile("java.log","rw");
      myRAFile.seek(myRAFile.length());
    现在文件的读写指针已经移至文件的末尾，如果在这之后使用任何流的write()方法，那么所写入的信息都将添加在原文件之后。

第七章小结：
  本章介绍了数据流的基本概念和主要的操作方法，通过这些方法可以实现基本的输入/输出功能。要掌握两种基本的数据流，包括文件数据流、过滤器数据流、缓冲数据流等在内的字节数据流，以及读者和写者在内的字符数据流。
  本章还介绍了对文件进行操作的File类和RandomAccessFile随机存取文件类。要掌握对文件进行操作的基本方法。


第八章、图形界面设计
第一节、AWT与Swing
  图形用户界面(Graphical User Interface,GUI)是大多数程序不可缺少的部分，Java的图形用户界面由各种组件构成，在java.awt包和javax.swing包中定义了多种用于创建图形用户界面的组件类。设计图形用户界面时一般有3个步骤，分别是选取组件、设计布局及响应事件。
  早期的JDK版本中提供了Java抽象窗口工具集(Abstract Window Toolkit,AWT)，为程序员创建图形用户界面提供支持。后来的JDK版本中，又提供了功能更强的Swing。AWT组件定义在java.awt包中，Swing组件定义在javax.swing包中。
  AWT和Swing包含了部分对应的组件，例如，标签和按钮，在java.awt包中分别用lable和Button表示，而在javax.swing包中，则分别用JLabel和JButton表示，多数Swing组件以字母"J"开头。
  Swing组件与AWT组件最大的不同是Swing组件在实现时不包含任何本地代码，因此Swing组件可以不受硬件平台的限制，而具有更多的功能。基于AWT的界面可能会因运行平台的不同略有差异，而基于Swing的界面在任何平台上的显示效果都是一致的。
  不包含本地代码的Swing组件被称为"轻量级"组件，而包含本地代码的AWT组件被称为"重量级"组件。当"重量级"组件与"轻量级"组件一同使用时，如果组件区域有重叠，那么"重量级"组件将覆盖"轻量级"组件。在Java2平台上推荐使用Swing组件。
  Swing组件比AWT组件拥有更多的功能，例如，Swing中的按钮和标签不仅可以显示文本信息，还可以显示图标，或同时显示文本和图标；大多数Swing组件都可以添加和修改边框；Swing组件的形状是任意的，而不仅局限于长方形。
  Java的图形用户界面由各种组件构成，组件时构成图形用户界面的基本元素。例如，按钮(JButton)、文本输入框(JTextField)、标签(JLabel)等都是组件。
  框架(Frame)、面板(Panel)等组件称为容器(Container)，它们是特殊的组件，可以包含组件，各种组件(包括容器)可以通过add()方法添加到容器中。Java语言为每种组件都定义了类，通过这些类或是它们的子类可以创建组件对象。通过相关方法可以对界面进行控制及响应。

第二节、容器
  组件可以分为容器组件和非容器组件。所谓容器组件是指可以包含其它组件的组件，又分为顶层容器和一般用途容器。而非容器组件则必须要包含在容器中。
  显示在屏幕上的所有组件都必须包含在某个容器中，有些容器可以嵌套，在这个嵌套层次的最外层，必须是一个顶层容器。此外，还有一些容器时不能当作顶层容器的，例如，Jpanel和JscrollPane。Java为所有容器类定义了一个父类Container，容器的共有操作都在定义Container类中。
  1.顶层容器：
    Swing中提供了4种顶层容器，分别为JFrame、JApplet、JDialog和JWindow。JFrame是一个带有标题行和控制按钮(最小化、恢复/最大化、关闭)的独立窗口，有时称为框架，创建应用程序时需要使用JFrame。创建小应用程序时使用JApplet，它被包含在浏览器窗口中。创建对话框时使用JDialog。JWindow是一个不带有标题行和控制按钮的窗口，通常很少用。
    JFrame类常用的构造方法有以下几种:
      JFrame(): 构造一个初始时不可见、无标题的新框架窗体。
      JFrame(String title): 构造一个初始时不可见、具有指定标题的新框架窗体。
    JFrame类中定义了一些相关方法，另外也从祖先类中继承了一些方法。常用的方法有以下几种:
      void setBounds(int x,int y,int width,int height): 移动并调整框架大小。左上角位置的横纵坐标分别由x和y指定，框架的宽高分别由width和height指定。
      void setSize(int width,int height): 设置框架大小。框架的宽高分别由width和height指定。
      void setBackgroud(Color bg): 设置框架的背景颜色。
      void setVisible(boolean b): 使框架可见或不可见。
      void pack(): 调整框架的大小，以合适其子组件的首选大小和布局。
      void setTitle(String): 设置框架的标题为字符串title。
      Container getContentPane(): 返回此框架窗体的内容窗格对象。
      void setLayout(LayoutManager manager): 设置布局管理器。
    程序8.1是一个使用JFrame创建应用程序的例子，运行该程序，将在屏幕上显示出一个窗口，窗口中有一个按钮：
      import javax.swing.*;
      import java.awt.*;
      public class SimpleFrameTest
      {
        public static void main(String[] args)
        {
          JFrame frame = new JFrame("测试窗口");     // 创建一个JFrame对象
          JButton button = new JButton("测试按钮");  // 创建按钮
          frame.getContentPane().add(button,BorderLayout.CENTER); // 将按钮添加到JFrame中
          frame.pack();                              // 调整大小
          frame.setVisible(true);                    // 设置窗口可见
          frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 退出时关闭窗口
        }
      }
    创建窗口用到的JFrame和JButton类定义在javax.swing包中，而BorderLayout定义在java.awt包中，程序的最开始要引用这两个包。主程序中首先创建了一个JFrame和一个JButton。JFrame是一个顶层级窗口，构造方法的参数指明了窗口的标题。
    JButton构造方法的参数指明了按钮上要显示的文字。JFrame可以改变窗口大小。在刚刚创建时，它的大小为0，并且不可见，需要使用frame.pack();语句调整窗口的大小，且使用frame.setVisible(true);语句来显示JFrame。pack()之前的语句，是将JButton放到JFrame的中央。
  
  2.内容窗格：
    4个顶层容器中的每一个都有一个内容窗格。除菜单之外，顶层容器中的组件都放在这个内容窗格中。有两种方法可以将组件放入内容窗格中，一种是通过顶层容器的getContentPane()方法获得其默认的内容窗格。
    getContentPane()方法的返回类型为java.awt.Container，它仍然是一个容器。然后将组件添加到内容窗格中，例如：
      Container contentPane =  frame.getContentPane();
      contentPane.add(button, BorderLayout.CENTER);
    上面两条语句也可合并为一条：
      frame.getContentPane().add(button, BorderLayout.CENTER);
    另一种方法是创建一个新的内容窗格，以取代顶层容器默认的内容窗格。通常的做法是创建一个JPanel的实例，它是java.awt.Container的子类。然后将组件添加到JPanel实例中，再通过顶层容器的setContentPane()方法将JPanel实例设置为新的内容窗格，例如：
      JPanel contentPane = new JPanel();              // 创建JPanel对象
      contentPane.setLayout(new BorderLayout());      // 创建布局管理器
      contentPane.add(button, BorderLayout.CENTER);   // 添加组件
      frame.setContentPane(contentPane);              // 添加内容窗格
    顶层容器默认内容窗格的布局管理器是BorderLayout，而JPanel默认的布局管理器是FlowLayout，因此需要为JPanel实例设置一个BorderLayout布局管理器。
    程序8.2 改写程序8.1中的JFrame示例：
      import java.awt.*;
      import javax.swing.*;
      public class JFrameDemo2 {
        public static void main(String args[]) {
          JFrame frame = new JFrame("JFrameDemo2");       // 创建一个JFrame的实例
          JButton button = new JButton("press me");       // 创建一个JButton的实例
          JPanel contentPane = new JPanel();              // 创建一个JPanel的实例
          contentPane.setLayout(new BorderLayout());      // 为JPanel设置BorderLayout布局管理器
          contentPane.add(button, BorderLayout.CENTER);   // 将JButton放到JPanel的中央
          frame.setContentPane(contentPane);              // 将JFrame设置新的内容窗口
          frame.pack();                                   // 将JFrame设置为适当的大小
          frame.setVisible(true);                         // 显示JFrame
          frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 退出时关闭窗口
        }
      }
    向顶层容器的内容中添加组件时，可以直接调用顶层容器的add()方法，这与掉哟个内容窗格的add()方法是等价的。

  3.面板：
    普通面板(JPanel)和滚动面板(JScrollPane)都是用途广泛的容器。与顶层容器不同的是，面板不能独立存在，必须被添加到其他容器内部。面板可以嵌套，由此可以设计出复杂的图形用户界面。
    当容器中组件过多而不能在显示区域内全部显示时，可以让容器带滚动条，从而显示出全部的组件，使用滚动面板可以实现这个功能。
      JPanel(): 创建具有FlowLayout布局的新面板。
      JPanel(LayoutManager layout): 创建具有指定布局管理器的新面板。
    使用public Component add(Component comp)方法可以将指定组件追加到面板中。
    程序8.3创建一个黄色普通面板，通过add()方法在面板中添加一个按钮，然后将该面板添加到JFrame的一个实例中，JFrame实例的背景色被设置为蓝绿色。
    import java.awt.*;
    import javax.swing.*;
    public class FrameWithPanel {
      public static void main(String args[]) {
        JFrame frame = new JFrame("Frame with Panel");  // 带标题的JFrame实例
        Container contentPane = frame.getContentPane(); // 获取内容窗格
        contentPane.setBackgroud(Color.CYAN);           // 将JFrame实例的背景色设置为蓝绿色
        JPanel panel = new JPanel();                    // 创建一个JPanel的实例
        panel.setBackgroud(Color.yellow);               // 将JPanel实例的背景色设置为黄色
        JButton button = new JButton("Press me");
        panel.add(button);                              // 将JButton实例添加到JPanel中
        contentPane.add(panel,BorderLayout.SOUTH);      // 将JPanel实例添加到JFrame的南侧
        frame.setSize(300,200); 
        frame.setVisible(true);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 退出时关闭窗口
      }
    }
    JScrollPane是带有滚动条的面板，它是Container类的子类。但是只能添加一个组件。所以当有多个组件需要添加时，一般是先将多个组件添加到JPanel中，然后再将这个JPanel添加到JScrollPane中。
    JScrollPane类中常用的构造方法有以下几种。
      ①JScrollPane(): 创建一个空的JScrollPane，需要时水平和垂直滚动条都可显示。
      ②JScrollPane(Component view): 创建一个显示指定组件内容的JScrollPane，只要组件的内容超过视图大小，就会显示水平和垂直滚动条。
    JScrollPane类中床用的方法有以下几种。
      ①void setHorizontalScrollBarPolicy(int policy): 确定水平滚动条合适显示在滚动窗格上。
        参数policy的可选值为下列三者之一。
        ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED: 需要时可见。
        ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER: 总是不可见。
        ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS: 总是可见的。
      ②void setVerticalScrollBarPolicy(int policy): 确定垂直滚动条何时显示在滚动窗格上。
        参数policy的可选值为下列三者之一:
        ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED: 需要时可见。
        ScrollPaneConstants.VERTICAL_SCROLLBAR_NERVER: 总是不可见。
        ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS: 总是可见的。
    AWT中还有一个滚动条组件，提供一个允许用户在一定范围的值中进行选择的便捷方式。滚动条的构造方法有以下几种。
      ①Scrollbar(): 构造一个新的垂直滚动条。
      ②Scrollbar(int orientation): 构造一个具有指定方向的新滚动条。orientation指示滚动条的方向，其值是Scrollbar.HORIZONTAL或者Scrollbar.VERTICAL，分别指示滚动条是水平还是垂直滚动条。
      ③Scrollbar(int orientation, int value, int visible, int minimum, int maximum): 构造一个新的滚动条，它具有指定的方向，初始值，可视量，最小值和最大值。orientation的值如前所述，value是滚动条的初始值，visible是滚动条的可视量，通常由滑动块的大小表示，minimum是滚动条的最小值，maximum是滚动条的最大值。

第三节、标签
  1.标签：
    标签(JLabel)对象是最简单的Swing组件，通常用于显示提示性的文本信息或图标，不可被编辑，其构造方法有以下6种形式：
      ①JLabel(): 创建一个既不显示文本信息又不显示图标的空标签。
      ②JLabel(Icon image): 创建一个显示图标的标签。
      ③JLabel(String text): 创建一个显示文本信息的标签。
      ④JLabel(Icon image, int horizontalAlignment): 创建一个显示图标的标签，水平对齐方式由int型参数horizontalAlignment指定。
      ⑤JLabel(String text, int horizontalAlignment): 创建一个显示文本信息的标签，水平对齐方式由int型参数horizontalAlignment指定。
      ⑥JLabel(String text, Icon image, int horizontalAlignment): 创建一个同时显示文本信息和图标的标签，水平对齐方式由int型参数horizontalAlignment指定。
    构造方法中，表示水平对齐方式的int型参数horizontalAlignment的取值可以为JLabel.LEFT、JLabel.RIGHT和JLabel.CENTER常量，分别表示左对齐、右对齐和居中对齐。
    例如：
      JLabel label = new JLabel("Hello",JLabel.RIGHT);
    该命令构造一个以右对齐方式显示的标签。
    默认情况下，标签内容在垂直方向上居中显示，只有文本信息的标签在水平方向上左对齐，只有图标的标签在水平方向上居中显示。
    通过setHorizontalAlignment(int alignment)方法可以设置标签内容的水平对齐方式，通过setVerticalAlignment(int alignment)方法可以设置标签内容的垂直对齐方式。
    例如，下面命令将显示内容设置为水平居中、底部对齐。
      label.setHorizontalAlignment(JLabel.CENTER);
      label.setVerticalAlignment(JLabel.BOTTOM);
    程序中可以使用setText(String text)方法修改显示在标签上的文本信息，也可以使用setIcon(Icon icon)方法修改标签上的图标。

  2.按钮：
    按钮(JButton)是Java图形用户界面的基本组件之一，经常用到的按钮有4种形式：JButton、JToggleButton、JCheekBox和JRadioButton，它们均是AbstractButton的子类或间接子类。各种按钮上都可以设置文本，设置图标，注册事件侦听程序。
    在AbstractzButton中定义了按钮所共有的一些方法，例如addActionListener()、setEnabled()、setText()和setIcon()等。
    JButton是最简单的按钮，常用的构造方法有以下几种。
      ①JButton(): 创建一个既没有显示文本也没有显示图标的按钮。
      ②JButton(Icon icon): 创建一个没有显示文本但是有图标的按钮。
      ③JButton(String text): 创建一个有显示文本但是没有图标的按钮。
      ④JButton(String text, Icon icon): 创建一个既有显示文本又有图标的按钮。
    例如下面的这条命令，构造一个显示文本为"Sample"、带有钻石形状大小图标的按钮。
      JButton b = new JButton("sample", new ImageIcon("icon.gif"));
    当用户用鼠标单击按钮时，事件处理系统将向按钮发送一个ActionEvent事件类对象，如果程序需要对此做出反应，则需要使用addActionListener()为按钮注册事件侦听程序并实现ActionListener接口。
    JButton类的常用方法有以下几种。
      ①public void setMnemonic(int mnemonic): 设置当前按钮的键盘助记符。
      ②public void setText(String text): 设置按钮的文本。
      ③public String getText(): 返回按钮的文本。
      ④public void setToolTipText(String text): 设置要显示的提示文本。
      ⑤public void addActionListener(ActionListener I);
    程序示例请查看程序8_4.java
    程序运行中，可通过setText()方法动态地改变按钮上显示的文本，通过setEnabled()方法改变按钮的状态。

  3.切换按钮、复选按钮及单选按钮
    除了普通按钮JButton外，还有切换按钮(JToggleButton)、复选按钮(JCheckBox)和单选按钮(JRadioButton)。
    JToggleButton是具有两种状态的按钮，即选中状态和未选中状态。
    JToggleButton的构造方法主要有以下几种格式。
      JToggleButton(): 创建一个既没有显示文本又没有显示图标的切换按钮。
      JToggleButton(Icon icon): 创建一个没有显示文本但有显示图标的切换按钮。
      JToggleButton(Icon icon, boolean selected): 创建一个没有显示文本但有图标和指定初始状态的切换按钮。
      JToggleButton(String text): 创建一个有显示文本但没有图标的切换按钮。
      JToggleButton(String text, boolean selected): 创建一个有显示文本和指定初始状态但没有图标的切换按钮。
      JToggleButton(String text, Icon icon): 创建一个既没有显示文本又没有显示图标的切换按钮。
      JToggleButton(String text, Icon icon, boolean selected); 创建一个既有显示文本又有图标和指定初始状态的切换按钮。
    构造方法中如果没有指定按钮的初始状态，则默认处于未选中状态。
    JCheckBox和JRadioButton都是JToggleButton的子类，构造方法的格式与JToggleButton相同，它们也都具有选中和未选中两种状态。
    在JToggleButton类中定义了一个isSelected()方法，通过该方法可以获知按钮的当前状态：当返回值为true时表示处于选中状态，而返回false则表示处于未选中状态。
    程序示例请查看程序8_5.java

第四节、布局管理器
  容器中包含了组件。组件的布局，包括各组件的位置和大小，通常由布局管理器负责安排。每个容器，例如JPanel或者顶层容器的内容窗格，都有一个默认的布局管理器，可以通过容器的setLayout()方法改变容器的布局管理器。
  Java平台提供了多种布局管理器，本节将介绍较常用的几个。
  1.FlowLayout布局管理器
    FlowLayout定义在Java.awt包中，这个布局管理器对容器中组件进行布局的方式是将组件逐个地放置在容器中的一行上，一行放满后就另起一个新行。它有3种构造方法。
      ①FlowLayout(): 创建一个默认的FlowLayout布局管理器，居中对齐，默认的水平和垂直间距是5个像素。
      ②FlowLayout(int align): 创建一个新的FlowLayout布局管理器，对齐方式是指定的，默认的水平和垂直间距是5个像素。
      ③FlowLayout(int align, int hgap, int vgap): 创建一个新的FlowLayout布局管理器，具有指定的对齐方式以及指定的水平和垂直间距。
    在默认情况下，FlowLayout将组件居中放置在容器的某一行上。如果不想采用这种居中对齐的方式，FlowLayout的构造方法中提供了一个对齐方式的可选项align，可以将组件的对齐方式设定为左对齐或者右对齐。
    align的可取值有FlowLayout.LEFT、FlowLayout.RIGHT和FlowLayout.CENTER三种形式，分别对应组件的左对齐，右对齐和居中对齐三种方式，例如：new FlowLayout(FlowLayout.LEFT); 创建了一个使用左对齐方式对齐的FlowLayout实例。
    此外，FlowLayout的构造方法中还有一对可选项hgap和vgap，可用来设定组件的水平间距和垂直间距。与其他布局管理器不同的是，FlowLayout布局管理器并不强行设定组件的大小，而是允许组件拥有它们自己所希望的尺寸。每个组件都有一个getPreferredSize()方法，容器的布局管理器会调用这一方法取得每个组件希望的大小。
    下面是几个使用setLayout()方法实现FlowLayout的例子。
      setLayout(new FlowLayout(FlowLayout.RIGHT, 20, 40));
      setLayout(new FlowLayout(FlowLayout.LEFT));
      setLayout(new FlowLayout());
    程序示例请查看程序8_6.java 
    
  2.BorderLayout布局管理器


  3. GridLayout布局管理器


  4.CardLayout布局管理器


  5.BoxLayout布局管理器


  6.空布局



第五节、事件处理
  在Java程序运行时，如果用户进行某个操作，比如单击鼠标键或者输入字符，程序应当做出适当响应。用户在程序界面所进行的操作称为用户事件。对事件的响应称为事件处理。
  1.事件处理模型

  2.事件的种类

  3.事件适配器


第六节、绘图基础

  1.颜色

  2.字体

  3.Graphics类的基本功能

  4.Graphics2D绘图


第八章小结：



第九章、Swing组件
第一节、组合框与列表
  1.组合框

  2.列表

第二节、文本组件
  1.文本域

  2.文本区

第三节、菜单组件
  1.菜单栏及菜单

  2.菜单项

  3.复选菜单项和单选菜单项

第四节、对话框
  1.对话框

  2.标准对话框

  3.文本对话框


第九章小结：


  





第十章、多线程
第一节、线程和多线程
  1.线程的概念：
    进程的概念： 对于一般程序而言，其结构大豆可以划分为一个入口，一个出口和一个顺次执行的语句序列。在程序要投入运行时，系统从程序入口开始按语句的顺序(包括顺序，分支和循环结构)完成相应指令直至结尾，再从出口退出，整个程序结束。
    这样的语句结构被成为进程，它是程序的一次动态执行，对应了从代码加载、执行至执行完毕的一次完整过程；或者说进程就是程序在处理机中的一次运行。在这样的一个结构中不仅包括了程序代码，同时也包括系统资源的概念。
    具体来说，一个进程既包括其所要执行的代码，又包括执行指令所需的任何系统资源，如CPU、内存空间、I/O端口等，不同进程所占用的系统资源相对独立

    线程的概念： 线程是进程执行过程中产生的多条执行线索，是比进程单位更小的执行单元，在形式上同进程十分相似——都是用一个按序执行的语句序列来完成特定的功能。不同的是它没有入口也没有出口，因此自身不能自动运行，而是必须栖身于某一个进程中，由进程触发执行。
    在系统资源的使用上，属于同一进程的所有线程共享该进程的系统资源，但是线程之间切换速度比进程切换要快得多。

    在单CPU的计算机内部，从微观上讲，一个时刻只能有一个作业被执行。实现多线程就是要在宏观上使多个作业被同时执行。多线程可以使系统资源特别是CPU的利用率得到提高，整个程序的执行效率也可以得到提高。
    为了达到多线程的效果，Java语言把线程或执行环境(Execution Context)当作一个封装对象，包含CPU及自己的程序代码和数据，由虚拟机提供控制。Java类库中的类java.lang.Thread允许创建这样的线程，并可控制所创建的线程。

  2.线程的结构：
    在Java中，线程由以下3部分组成。
      虚拟CPU，封装在java.lang.Thread类中，它控制着整个线程的运行。
      执行的代码，传递给Thread类，由Thread类控制按序执行。
      处理的数据，传递给Thread类，是在代码执行过程中所要处理的数据。
    当一个线程被构造时，它由构造方法参数、执行代码、操作数据来初始化。这三个方面是各自独立的。一个线程所执行的代码与其他线程可以相同也可以不同，一个线程访问的数据与其他线程可以相同也可以不同。
    与传统的进程相比，多线程编程简单、效率高。使用多线程可以在线程间直接共享数据和资源，而多进程之间不能做到这一点。多线程适合于开发有多种交互接口的程序。多线程的机制可以减轻编写交互频繁、涉及面多的程序的困难，如侦听网络端口的程序。程序中可以同时侦听多种设备，如网络端口、串口、并口以及其他外设等。
    对多线程的支持是Java语言的一个重要特色，它提供了Thread类来实现多线程。

  3.线程的状态：
    Java的线程是通过java.lang中定义的类Thread来实现的。当生成一个Thread类的对象后就产生了一个线程。通过该对象的实例，可以启动线程，终止线程，或者暂时挂起线程等。
    Thread类本身只是线程的虚拟CPU，线程所执行的代码，或者说线程所要完成的功能，是通过方法run()来完成的，方法run()称为线程体，包含在一个特定的对象中。实现线程体的特定对象是在初始化线程时传递给线程的。在一个线程被建立并初始化以后，Java运行时系统自动调用run()方法，建立线程的目的得以实现。
    线程一共有4种状态，分别是新建(NEW)、可运行状态(Runnable)、死亡(Dead)及阻塞(Blocked),如下所示:

          新建 -------->  可运行状态  <---------> 阻塞
                              |
                              v
                            死 亡
    3.1 新建：
      线程对象刚刚创建，还没有启动，此时还处于不可运行状态。此时刚创建的线程处于新建状态，但已有了相应的内存空间以及其他资源。
    3.2 可运行状态：
      此时的线程已经启动，处于线程的run()方法之中。这种情况下线程可能正在运行，也可能没有运行，只要CPU一空闲，马上就会运行。可以运行但没有运行的线程都排在一个队列中，这个队列称为就绪队列。
      可运行状态中，正在运行的线程处于运行状态，等待运行的线程处于就绪状态。一般地，单CPU情况下，最多只有一个线程处于运行状态，可能会有多个线程处于就绪状态。
      调用线程的start()方法可使线程处于可运行状态。
    3.3 死亡：
      线程死亡的原因有两个：一是run()方法中最后一个语句执行完毕，二是当线程遇到异常退出时便进入了死亡状态。
    3.4 阻塞：
      一个正在执行的线程因特殊原因，被暂时执行，就进入阻塞状态。阻塞时线程不能进入就绪队列排队，必须等到引起阻塞的原因消除，才可重新进入队列排队。
    3.5 中断线程：
      在程序中常常调用interrupt()来终止线程。interrupt()不仅可中断正在运行的线程，而且也能中断处于blocked状态的线程，此时interrupt()会抛出一个InterruptedException异常。
      Java提供了几个用于测试线程是否被中断的方法。
        void interrupt(): 向一个线程发送一个中断请求，同时把这个线程的"interrupted"状态置为true。若该线程处于"blocked"状态，会抛出InterruptException异常。
        static boolean interrupted(): 检测当前线程是否已被中断，并重置状态"interrupted"值。即如果连续两次调用该方法，则第二次调用将返回false。
        boolean isInterrupted(): 检测当前线程是否已被中断，不改变状态"interrupted"值。

第二节、创建线程
  创建线程有两种方法，一种是定义一个继承Thread类的子类，另一种是实现Runnable接口。
  1.继承Thread类创建线程
    java.lang.Thread是Java中用来表示线程的类，如果将一个类定义为Thread的子类，那么这个类的对象就可以用来表示线程。
    Thread类中一个典型的构造方法如下。
      Thread(ThreadGroup group, Runnable target, String name)
    其中，name作为新线程的名称，且是线程组group中的一员，而target必须实现Runnable接口，它是另一个线程对象，当本线程启动时，将调用target的run()方法；当target为null时，启动本线程的run()方法。在Runnable接口中只定义了一个方法，即void run()，该方法作为线程体。
    任何实现Runnable接口的对象都可以作为一个线程的目标对象。构造方法中各参数都可以缺省。Thread类本身也实现了Runnable接口。
    定义一个线程类，它继承Thread类并重写方法run()。由于Java只支持单重继承，用这种方法定义的类不能再继承其他类。
    用Thread类的子类创建线程的过程包括以下3步。
      ①从Thread类派生出一个子类，在类中一定要实现run()。
        class Lefthand extends Thread {
          public void run() { ... }
        }
      ②然后用该类创建一个对象。如 Lefthand left = new Lefthand();
      ③用start()方法启动线程。如 left.start();
    程序示例请查看程序10_1.java
    程序10_1中定义了两个类Lefthand和Righthand，它们都是Thread类的子类，所以都是线程类，也都覆盖了父类的run()方法。在程序10_1类中，分别创建了线程对象，并且不需要给出任何参数。然后使用start()方法启动线程。两个线程的线程体是不一样的，它们输出不同的信息。当启动线程后，它们的执行顺序依系统来决定，所以输出的结果带有部分随机性。

  2.实现Runnable接口创建线程
    Runnable是Java中用以实现线程的接口，从根本上讲，任何实现线程功能的类都必须实现该接口。前面所用到的Thread类实际上就是因为实现了Runnable接口，所以它的子类才相应具有线程功能。
    Runnable接口中只定义了一个方法就是run()方法，也就是线程体。用Runnable接口实现多线程时，也必须实现run()方法，也需要使用start()启动线程，但此时常用Thread类的构造方法来创建线程对象。
    Thread的构造方法中包含有一个Runnable实例的参数，即必须定义一个实现Runnable接口的类并产生一个该类的实例，对该实例的引用就是适合于这个构造方法的参数。
    例：编写线程体
      public class xyz extends Runnable {
        int i;
        public void run() {
          while(true) {
            System.out.println("Hello" + i++);
          }
        }
      }
    利用类xyz可以构造以下线程：
      Runnable r = new xyz();
      Thread t = new Thread(r);
    这样就定义了一个由t表示的线程，它用来执行xyz类的run()方法中的程序代码(接口Runnable要求实现方法public void run())。这个线程使用的数据由r所引用的xyz类的对象提供。
    示例10.2：Runnable接口创建线程：
      class TwoThread implements Runnable {
        private int i;
        public void run() {
          for( ; i < 20;i++) {
            System.out.println(Thread.currentThread().getName() + "\t" + i);
            if(i==20){
              System.out.println(Thread.currentThread().getName() + "\t" + "over");
            }
          }
        }
      }
      public class MyThreadTest {
        public static void main(String[] args) {
          for(int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName() + "\t" + i);
            if(i == 5) {
              TwoThread t1 = new TwoThread();
              Thread thread1 = new Thread(t1, "线程1");
              Thread thread2 = new Thread(t1, "线程2");
              thread1.start();
              thread2.start();
            }
          }
        }
      }
    在以上示例中，TwoThread是实现了Runnable接口的类，所以可以使用它创建线程t1。然后又将t1作为Thread构造方法中的target创建了两个线程thread1和thread2.这两个线程使用的是同一个t1，它们共享t1，即都执行t1的run()方法。
    执行过程中，先输出几次主线程main的名字。之后，主线程与两个新线程共享的信息随机输出。

  3.创建线程两种方法的适用条件
    既然两种方法创建线程效果相同，那么使用哪种方法更好？如何决定选择两种方法的哪一种呢？下面分别列出了每种方法的适用范围。
    3.1 适用于采用实现Runnable接口方法的情况
      因为Java只允许单重继承，如果一个类已经继承了Thread，就不能再继承其他类，在一些情况下，这就被迫采用实现Runnable的方法。另外，由于原来的线程采用的是实现Runnable接口的方法，可能会出于保持程序风格的一贯性而继续使用这种方法。
    3.2 适用于采用继承Thread方法的情况
      当一个run()方法置于Thread类的子类中时，this实际上引用的是控制当前运行系统的Thread实例，所以，代码不必写的想这样: Thread.currentThread().getState(); 而是简写为: getState(); 因为代码稍微简洁一些，所以许多程序员愿意使用继承Thread的方法。

第三节、线程的基本控制
  1.线程的启动：
    虽然一个线程已经被创建，但它实际上并没有立刻运行。要使线程真正地在Java环境中运行，必须通过方法start()来启动，start()方法也在Thread类中。
    在程序10.2中，只需要执行:
      thread1.start();
      thread2.start();
    此时，线程中的虚拟CPU已就绪。
    API中提供了以下有关线程的操作方法。
      start():  启动线程对象，让线程从新建状态转为就绪状态。
      run():    用来定义线程对象被调度后所执行的操作，用户必须重写run()方法。
      yield():  强制终止线程的执行。
      isAlive():  测试当前线程是否在活动。
      sleep(int millsecond):  使线程休眠一段时间，时间长短由millsecond决定，单位为ms。
      void wait():  使线程处于等待状态。

  2.线程的调度：
    虽然就绪线程已经可以运行，但这并不意味着这个线程一定能够立刻运行。显然，在一台实际上只具有一个CPU的机器上，CPU在同一时间只能分配给一个线程做一件事。那么当有多于一个的线程工作时，CPU是如何分配的？这就是线程的调度问题。
    在Java中，线程调度通常是抢占式，而不是时间片式。抢占式调度是指可能有多个线程准备运行，但只有一个在真正运行。一个线程获得执行权，这个线程将持续运行下去，直到它允许结束或因为某种原因而阻塞，再或者有另一个高优先级线程就绪，最后一种情况称为低优先级线程被高优先级线程所抢占。
    每个线程都有一个优先级，Java的线程调度采用如下的优先级策略。
      ①优先级高的先执行，优先级低的后执行。
      ②每个线程创建时都会被自动分配一个优先级，默认时，继承其父类的优先级。
      ③任务紧急的线程，其优先级较高。
      ④同优先级的线程按"先进先出"的调度原则。
    Thread类有3个与线程优先级有关的静态量，分别如下：
      ①MAX_PRIORITY:  最高优先级，值为10。
      ②MIN_PRIORITY:  最低优先级，值为1。
      ③NORM_PRIORITY: 默认优先级，值为5。
    java.lang.Thread类中有关优先级的几个常用方法如下。
      ①void setPriority(int newPriority): 重置线程优先级。
      ②int getPriority(): 获得当前线程的优先级。
      ③static void yield(): 暂停当前正在执行的线程，即让当前线程放弃执行权。
    一个线程被阻塞的原因是多种多样的，可能是因为执行了Thread.sleep()调用，故意让它暂停一段时间；也可能是因为需要等待一个较慢的外部设备，例如磁盘或用户操作的键盘。所有被阻塞的线程按次序排列，组成一个阻塞队列。而所有就绪但没有运行的线程则根据其优先级进入一个就绪队列。
    当CPU空闲时，如果就绪队列不空。队列中第一个具有最高优先级的线程将运行。当一个线程被抢占而停止运行时，它的运行状态被改变并放到就绪队列的队尾; 同样，一个被阻塞(可能因为睡眠或等待I/O设备)的线程就绪后通常也放到就绪队列的队尾。
    由于Java线程调度不是时间片式，所以在程序设计时要合理安排不同线程之间的运行顺序，以保证给其他线程留有执行的机会。为此，可以通过间隔地调用sleep()做到这一点。
    例子10.2 调度
      public class Xyz extends Thread {
        public void run() {
          while(true) {
            ......// 执行若干操作
            // 给其他线程运行的机会
            try {
              Thread.sleep(10);
            }catch(interruptedException e) {}
          }
        }
      }
    sleep()是Thread类中的静态方法，因此可以通过Thread.sleep(x)直接调用。参数x指定了线程在再次启动前必须休眠的最小时间，以毫秒为单位。同时该方法可能引发中断异常InterruptedException，因此要进行捕获和处理。
    这里说"最小时间"是因为这个方法只保证在一段时间后线程回到就绪状态，至于它是否能够获得CPU运行，则要视线程调度而定，所以，通常线程实际被暂停的时间都比指定的时间要长。
    除sleep()方法以外，Thread类中的另一个方法yield()可以给其他同优先级线程一个运行的机会。如果在就绪队列中有其他同优先级的线程，yield()把调用者放到就绪队列尾，并允许其他线程运行；如果没有这样的线程，则yield()不做任何工作。
    sleep()调用允许低优先级进程运行，而yield()方法只给同优先级进程以运行机会。

  3.结束线程：
    当一个线程从run()方法的结尾处返回时，它自动消亡并且不能再被运行，可以将其理解为自然死亡。另一种情况是遇到异常使得线程结束，可以将其理解为强迫死亡。还可以使用interrupt()方法中断线程的执行。
    在程序代码中，可以利用Thread类中的静态方法currentThread()来引用正在运行的线程。有时候可能不知道一个线程的运行状态，这时可以使用方法isAlive()来获取一个线程是否还在活动状态的信息。活动状态不意味着这个线程正在执行，而只说明这个线程已被启动。

  4.挂起线程：
    有几种方法可以用来暂停一个线程的运行，暂停一个线程也称为挂起。在挂起之后，必须重新唤醒线程进入运行状态，只是线程执行命令的速度非常慢。挂起线程的方法有以下几种。
      4.1 sleep()
        sleep()方法用于暂时停止一个线程的执行。通常，线程不是休眠期满后就立刻被唤醒，因为此时其他线程可能正在执行，重新调度只在以下几种情况下才会发生。
          >被唤醒的线程具有更高的优先级。
          >正在执行的线程因为其他原因被阻塞。
          >程序处于支持时间片的系统中。
        大多数情况下，后两种条件不会立刻发生。

      4.2 wait()和notify()/notifyAll() 
        wait()方法导致当前的线程等待，直到其他线程调用此对象的notify()方法或者notifyAll()方法，才能唤醒线程。

      4.3 join()
        join()方法将引起现行线程等待，直至join()方法所调用的线程结束。比如在线程B中调用了线程A的join()方法，直到线程A执行完毕后，才会继续执行线程B。可以想象成将线程A加入到当前线程B中。
        join()方法在调用时也可以使用一个以毫秒计的时间值：
          void join(long timeout);
        此时join()方法将挂起现行线程timeout毫秒，或直到调用的线程结束，实际挂起时间以二者中较少的为准。

第四节、线程的互斥
  1.互斥问题的提出
    通常，一些同时运行的线程需要共享数据。此时，每个线程就必须要考虑与它一起共享数据的其他线程的状态与行为，否则的话就不能保证共享数据的一致性，因而也就不能保证程序的正确性。
    下面设计一个代表栈的类。这个类没有采取措施处理溢出，栈的能力也很有限。
    例10.3 栈示例。
      class Stack {
        int idx = 0;
        char data[] = new char[6];
        public void push(char c) {
          data[idx] = c;
          idx ++;
        }
        public char pop() {
          idx --;
          return data[idx];
        }
      }
    栈具有"后进先出"模式，它使用下标值idx表示栈中下一个放置元素的位置。现在设想有两个独立的线程A和线程B都具有对这个类的同一个对象的引用，线程A负责入栈，线程B负责出栈。要求线程A放入栈中的数据都要由线程B读出，不重不漏。
    表面上，通过以上的代码，数据将被成功地移入移出，但因为入栈方法push()及出栈方法pop()中含有多条语句，执行过程中仍然存在着潜在的问题。
    假设此时栈中已经有字符1和2，当前线程A要入栈一个字符3，调用push(3),执行了语句data[idx] = c; 后被其他线程抢占了，此时尚未执行idx ++语句。故idx指向最后入栈的字符的下标，示意如下：
    data  1  2  3
    idx=2       ^
    如果此时线程A马上被唤醒，可以继续修正idx的值，从而完成一次完成的入栈操作。如若不然，入栈操作执行了一半。若恰巧线程B此时占用CPU，调用pop()，执行出栈操作，则它返回的字符是2，因为它先执行idx--语句，idx的值变为1，返回的是data[1]处的字符，即字符2。字符3被漏掉了。
    这个简单的例子说明的就是多线程访问共享数据时通常会引起的问题。产生这种问题的原因是对共享资源访问的不完整性。为了解决这种问题，需要寻找一种机制来保证对共享数据操作的完整性，这种完整性被称为共享数据操作的同步，共享数据叫作条件变量。
    可以选择的一种方法是禁止线程在完成代码关键部分时被切换。这个关键代码部分，对于线程A就是入栈操作及下标值增加这两个动作，对于线程B就是下标值递减及出栈操作这两个动作。它们要么一起完成，要么都不执行。在Java中，提供了一个特殊的锁定标志来处理共享数据的访问。

  2.对象的锁定标志
    在Java语言中，引入了“对象互斥锁”的概念，也称为监视器，使用它来实现不同线程对共享数据操作的同步。“对象互斥锁”阻止对各线程同时访问同一个条件变量。Java可以为每一个对象的实例配有一个“对象互斥锁”。
    在Java语言中，有两种方法可以实现“对象互斥锁”。
      ①用关键字volatile来声明一个共享数据(变量)。
      ②用关键字synchronized来声明操作共享数据的一个方法或一段代码
    在这样的处理方法下，可以将一个对象想象成一间实验室，它为众多实验人员共同使用，但任何时候实验室只允许一组实验人员在里面做实验，否则就会引起混乱。为了进行控制，在门口设置一把锁。实验室没人的时候锁是开放的，有人员进入后第一件事就是将门锁上，然后开始工作，直到里面的实验人员完成工作后将锁打开才允许再次进入。
    这种机制保证了在一组人员工作的过程中不会被另一组人员打断，也保证了数据操作的完整性。在同一时刻只能有一个任务访问的代码区称为临界区。
    现在修改例10.3，增加对象访问的同步性，如下：
    class stack {
      int idx = 0;
      char data[] = new char[6];
      public void push(char c) {
        synchronized(this) {
          data[idx] = c;
          idx ++;
        }
      }
    }
    当线程执行到被同步的语句时，它将传递的对象参数设为锁定标志，禁止其他线程对该对象的访问。同样地，如果pop()方法不进行修改，则当它被其他线程调用时，仍会破坏对象的一致性。因此，必须用同样办法修改pop()方法，如下：
    例10.5 锁定标志：
    public char pop() {
      synchronized(this) {    //增加同步标志
        idx --;
        return data[idx];
      }
    }
    现在pop()和push()操作的部分增加了一个对synchronized(this)的调用，在第一个线程拥有锁定标记时，如果另一个线程企图执行synchronized(this)中的语句时，它将从对象this中索取锁定标记。因为这个标记不可得，故该线程不能继续执行。实际上这个线程将加入一个等待队列，该等待队列与对象锁定标志相连，当标志被返还给对象时，等待标志的第一个线程将得到该标志并继续运行。
    因为等待一个对象的锁定标志的线程要等到持有该标志的线程将其返还后才能继续运行，所以在不使用该标志时将其返还就显得十分重要了。事实上，当持有锁定标志的线程运行完synchronized()调用包含的程序块后，这个标志将会被自动返还。
    Java保证了该标志通常能够被正确地返还，即使被同步的程序块产生了一个异常，或者某个循环中断跳出了该程序块，这个标志也能被正确返还。同样，如果一个线程两次调用了同一个对象，在退出最外层后这个标志也将被正确释放，而在退出内层时则不会执行释放。
    
    用synchronized标识的代码段或方法即为"对象互斥锁"锁住的部分。如果一个程序内有两个或以上的方法使用synchronized标志，则它们在同一个"对象互斥锁"的管理下。
    一般情况下，使用synchronized关键字在方法的层次上实现对共享资源操作的同步，很少使用volatile关键字声明共享变量。
    synchronized()语句的标准写法为：
      public void push(char c) {
        synchronized(this) {
            ......
        }
      }
    由于synchronized()语句的参数必须是this，因此，Java语言允许使用下面这种简洁的写法：
      public synchronized void push(char c) {
        ......
      }
    比较以上两种写法，可以看出，前一种比后一种更为妥帖。如果把synchronized用作方法的修饰字，则整个方法都将被视为同步块，这可能会使持有锁定标记的时间比实际需要的时间要长，从而降低效率。另一方面，使用前一种方法来做标记可以提醒他人同步在发生。
  
第五节、线程的同步
  为了完成多个任务，常创建多个线程，它们可能毫不相干，但有时它们完成的任务在某种程度上有一定的关系，此时就需要线程之间有一些交互。在Java中，使用一对方法wait()和notify()/notifyall()实现线程的交互。
  1.同步问题的提出:
    操作系统中的生产者消费者问题，就是一个经典的同步问题。举个简单例子：有两个人，一个人在刷盘子，另一个在烘干。这两个人各自代表一个线程，他们之间有一个共享的对象为盘架，刷好而等待烘干的盘子放在盘架上。两个人在没有事情做的时候都愿意歇着。
    显然，盘架上有刷好的盘子时，烘干的人才能开始工作；而如果刷盘子的人刷的太快，刷好的盘子占满了盘架时，他就不能再继续工作了，而要等到盘架上有空位置才行。
    这个示例要说明的问题是，生产者生产一个产品后就放入共享对象中，而不管共享对象中是否已有产品。消费者从共享对象中取用产品，但不检测是否已经取过。
      若共享对象中只能存放一个数据时，可能会出现以下问题：
        ①生产者比消费者快时，消费者会漏掉一些数据没有取到。
        ②消费者比生产者快时，消费者会取到相同的数据。
    在Java语言中，可以用wait()和notify()/notifyAll()方法来协调线程间的运行速度关系，这些方法都定义在java.lang.Object类中。

  2.解决方法：
    为了解决线程运行速度问题，java提供了一种建立在对象实例之上的交互方法。java中的每个对象实例都有两个线程队列和它相连。第一个用来排列等待锁定标志的线程。第二个则用来实现wait()和notify()的交互机制。
    类java.lang.Object中定义了3个方法 ，即wait()、notify()和notifyAll()。
    wait()方法导致当前的线程等待，它的作用是让当前线程释放其所持有的"对象互斥锁"，进入wait队列(等待队列)；而notify()/notifyAll()方法的作用是唤醒一个或所有正在等待队列中等待的线程，并将它(们)移入等待同一个"对象互斥锁"的队列。
    notify()/notifyAll()方法和wait()方法都只能被声明在synchronized的方法或代码段中调用。方法notify()最多只能释放等待对列中的第一个线程，如果有多个线程在等待，则其他的线程将继续留在队列中。notifyAll()方法能够释放所有等待线程。

    再来看前面刷盘子的例子。线程A代表刷盘子，线程B代表烘干，它们都有对盘架drainingBoard的访问权。假设线程B(烘干线程)想要进行烘干工作，而此时盘架是空的，则应表示如下：
      if(drainingBoard.isEmpty())
          drainingBoard.wait();  // 盘架空时则等待
    当线程B执行了wait()调用后，它不可再执行，并加入到对象drainingBoard的等待队列中。在有线程将它从这个队列中释放之前，它不能再次运行。
    那么烘干程序怎样才能重新运行呢？ 这应该由洗刷线程来通知它已经有工作可以做了，运行drainingBoard的notify()调用可以做到这一点。
      drainingBoard.addItem(plate); // 放入一个盘子
      drainingBoard.notify();
    此时，drainingBoard的等待队列中第一个阻塞线程从队列中释放出来，并可重新参加运行的竞争。
    注意，在这里使用notify()调用时，没考虑是否有正在等待的线程。事实上，应该只在增加盘子后使得盘架不再空时才执行这个调用。如果等待队列中没有阻塞线程时调用了方法notify()，则这个调用不做任何工作。notify()调用不会被保留到以后再发生效用。
    使用这个机制，程序能够非常简单地协调洗刷线程和烘干线程，而且并不需要了解这些线程的身份。每当执行了一项操作，使得另一个线程能够开始工作，就通知对象drainingBoard(调用notify());每当由于盘架空或满而不能继续工作时，就等待对象drainingBoard(调用wait())。
    在调用一个对象的wait()、notify()和notifyAll()时，必须首先持有该对象的锁定标志，因此这些方法必须在同步程序块中调用。这样，应该将代码改写如下：
      synchronized(drainingBoard) {
        if(drainingBoard.isEmpty()) 
            drainingBoard.wait();
      }
      和
      synchronized(drainingBoard) {
        drainingBoard.addItem(plate);
        drainingBoard.notify();
      }
    线程执行被同步的语句时必须要拥有对象的锁定标志，因此如果烘干线程被阻塞在wait()状态，洗刷线程不就永远不会执行到notify()语句了吗？
    实际的实现过程是不会出现这种情况的，因为在执行wait()调用时，Java将首先把锁定标志返回给对象，因此即使一个线程由于执行wait()调用而被阻塞，它也不会影响其他等待锁定标志的线程的运行。
    然而，为了避免打断程序的运行，当一个线程被notify()后，它并不立即变为可执行状态，而仅仅是从等待队列中移入锁定标志队列中。这样，在重新获得锁定标志之前，它仍旧不能继续运行。
    另一方面，在实际实现中，wait()方法既可以被notify()终止，又可以通过调用线程的interrupt()方法来终止。后一种情况下，wait()会抛出一个interruptedException异常，所以需要把它放在try/catch结构中。

第十章总结：
  线程和多线程是重要的概念，Java提供了语言级的线程控制，这是非常重要的特点。
  本章介绍线程的概念，线程各种状态之间转换的条件，线程的优先级，以及使用Thread类和Runnable接口创建线程的两种方式，还介绍了控制线程互斥和同步的基本知识。







