一、面向对象技术
  面向对象技术是一种软件开发方法，在面向对象程序设计方法出现之前，软件界广泛流行的是面向过程的设计方法，这种方法中使用的众多变量名和函数名互不约束，令程序员不堪重负。
  随着开发系统规模的不断扩大，面向过程的方法越来越不能满足开发人员的要求，面向对象技术应运而生，这种新技术使得程序结构简单，相互协作容易，更重要的是程序的重用性大大提升。
  所谓面向对象的方法学，就是使得分析、设计和实现一个系统的方法尽可能地接近人们认识一个系统的方法。
  通常分为三个方面：面向对象的分析(OOA)、面向对象的设计(OOD)、面向对象的程序设计(OOP)。面向对象技术包含的概念主要有抽象、对象、类、类型层次(子类)、封装、继承性、多态性等。
  Java语言是一种“纯”面向对象语言，它的所有数据类型，包括最基本的布尔型、数值型及字符型，都有相应的类，程序可以完全基于对象来编写。
  
二、OOP
  现实世界中存在很多同类的对象，他们来自于同一种原型，具有一样的共性。或者说它们来自与同一个模板。这就是类的概念。这其中的某个特定实体即为实例或称对象。对象是类的具相，类是对象的抽象。
  OOP技术把问题看成是相互作用的事物的集合，也就是对象的集合。对象具有两个特性，一是状态，二是行为。状态是指对象本身的信息，行为是实现对对象的操作。在OOP中，用属性来描述状态，而把对它的操作定义为方法。-->
  --> 属性也称为数据，这样的对象就是数据加方法。可以将现实生活中的对象经过抽象、映射为程序中的对象，
  OOP中采用了三大技术：封装、继承和多态。封装体现的特点是将对象的属性及实现细节隐藏起来，只给出如何使用的信息。
  1.封装：将数据及对数据的操作捆绑在一起成为类，这就是封装技术。对象是类的实例，外界使用对象中的数据收到类定义的限制
  2.继承：将一个已有类中的数据和方法保留，并加上自己特殊的数据和方法，从而构成一个新类，这是OOP中的继承。原来的类是父类，也称为基类或超类。新类是子类，子类派生与父类，或说子类继承父类。继承体现的是一种层次关系，下一层的类可以从上一层的类继承定义，同时还可以改变和扩充一些特性
  3.多态：在一个类或多个类中，可以让多个方法使用同一个名字，从而形成多态性。多态可以保证对不同类型的数据进行等同的操作，名字空间也更加宽松。多态还有一个重要的特点，即使用相同的操作名，能根据具体的对象自动选择对应的操作。
  
  
第二章第一节：
一、空白，注释及语句
  1.空白：在Java程序中，换行符和回车符都可以表示一行的结束，它们可以被看作空白。应该注意代码的格式，增加可阅读性
  2.注释：程序中适当的加入注释可以增加易读性，注释有三种形式：1.// 在一行内的注释  2./* 一行或者多行注释 */  3./** 文档注释 */ 
  3.语句、分号和块：语句是Java程序的最小执行单位，程序的各语句间以“;” 分隔。在 “{}” 内的一系列语句成为语句块。

二、关键字
  Java语言定义了许多关键字，关键字也称为保留字。它们都有各自的特殊意义和用途，不能把它们当成普通的标识符使用。
  Java关键字如下：
  abstract	 boolean    break	 byte	case 	cast	catch	char	class	const	continue	default		do 		double		else  	extends		false	 final	 finally	float	for
  future	generic		goto	 if		implements		import		innner		instanceof	  int		interface		long 	native		new		null	 operator	outer	 package	private		
  protected	 public		rest	return	short	static	strictfp	super		switch		synchronized(线程同步)	 this		throw	 throws		transient	 true	try		var		void  	volatile	while
  定义的这些关键字中，少数几个已不再使用。还有几个是预留的关键字，目前尚未使用。这些关键字是：cast, const, future, generic, goto, inner, operator, outer, rest和var等
 
三、标识符
  在Java中，标识符由字母、数字、下划线(_)或美元符号（$）组成的字符串，其中数字不能作为标识符的开头。标识符区分大小写，长度没有限制。除以上所列几项外，标识符中不能含有其他符号，当然也不许留空白，在程序中，标识符可用作变量名，方法名、接口名和类名等。
  Java源代码使用的是unicode码，而不是ASCII码

四、Java编程风格
  在编程时，应当注意自己的编程风格，增加必要的注释和空格，采用缩进格式。
  以下是常见的命名约定：
  1.类名或接口名：多为动词，含有大小写，首字母大写，其余各单词首字母大写。如HelloWorld..
  2.方法名：多是动词，含有大小写，首字母小写，其余各单词首字母大写，尽量不要在方法名中使用下划线。如getName\setAdress等
  3.常量名：简单类型常量的名字应该全部为大写字母，单词与单词之间用下划线分隔，对象常量可以使用混合大小写，如BLUE_COLOR。
  4.变量名：所有的实例变量，类变量，终极变量和静态变量等都使用混合大小写，首字符为小写，后面单词的首字母用大写。变量名中尽量不要使用下划线。如balance, orders等
  命名名称要有意义，尽量避免使用单字符名字，除非是临时使用的要“扔掉”的变量（比如在循环结构中的循环变量），总的来说就是要增加代码的可读性
 
第二节、基本数据类型
  Java的数据类型共分为两大类，一类是基本数据类型，另一类是复合数据类型。基本类型有八种，分为4小类，分别是整型，浮点型，字符型，和布尔型。整型和浮点型也合称为数值型。复合数据类型包括数组，类和接口。其中，数组也是一个很特殊的概念，它是对象，而不是一个类，一般把它归为复合数据类型。
  1.Java语言提供了4种整型量，对应的关键字分别是：byte, short, int 和 long。 它们的字节大小和可表示的范围分别是：
  byte(整数长度8位,字节数1)= -2的7次幂 ～ 2的7次幂-1 (-128~127)
  short(整数长度16位，字节数2)= -2的15次幂 ～ 2的15次幂-1（-32768～32767）
  int(整数长度32位，字节数4)= -2的31次幂 ～ 2的31次幂-1（-2,147,483,648～2,147,483,647）
  long(整数长度64位，字节数8)= -2的63次幂 ～ 2的63次幂-1（-9,223,372,036,854,775,808～9,223,372,036,854,775,807）
  整型常量是int型的。如果想表示一个长整型常量，需要在数的后面明确写出字母“L”。L表示它是一个long型量。这里，使用大写L或者小写l均有效。Java语言还提供了几个特殊的整型常量值表示最大值和最小值（比如int类型最大值为: integer.MAX_VALUE;最小是为integer.MIN_VALUE）
 
  2.Java浮点数类型遵从标准的浮点规则。浮点数类型有两种：一种是单精度浮点数，用float关键字说明;另一种是双精度浮点数，用double关键字说明，它们都是有符号数。
  float(浮点数长度32位，字节数4)= 1.4e-45f ~ 3.4028235e + 38f
  double(浮点数长度64位，字节数8)= 4.9e-324d~1.7976931348623157e + 308d
  如果数值常量中包含小数点，指数部分（字符E），或数的后面跟有字母F或字母D，则为浮点数。浮点数常量在默认情况下是double型的，除非用字母F明确说明它是float型。浮点型常量中的字母D或者F支持大小写。
  Java语言中有几个特殊的浮点数常量：float/double类型通用（最大值：Float.MAX_VALUE; 最小值：Float.MIN_VAlUE; 正无穷大：Float.POSITIVE_INFINITY; 负无穷大：Float.NEGATIVE_INFINITY; 0/0: Float.NaN;）
 
  3.字符类型char：单个字符用char类型表示。一个char表示一个Unicode字符，其值用16位无符号整数表示，范围为0～65535。char类型的常量值必须用一对单引号('')扩起来，分为普通字符常量和转义字符常量两种。
  使用单引号括住一个字符，表示一个普通的字符常量。但有些字符在Java语言中有特殊含义，常用转义符： \b表示退格键 \n表示换行符 \r表示回车符 \t表示水平制表符 \\表示一个反斜杠 \'表示一个单引号 \"表示一个双引号
  
  4.布尔类型boolean：逻辑值有两种状态，它们常被写作on和off，true和false，yes和no等。布尔类型也称为逻辑类型。bool类型有两个常量值：true和false，它们全是小写，在计算机内部用8位二进制数表示。
  Java是一种严格的类型语言，它不允许数值类型和布尔类型之间进行转换。不能向C/C++那样允许用数值表示逻辑值，如用0表示false，非0表示true。Java不允许这样做，需要使用逻辑值的地方不能以其他类型的值替代

第三节、表达式
  表达式由运算符和操作数组成，对操作数进行运算符指定的操作，并得出运算结果;
  Java运算符按功能可分为：算术运算符/ 关系运算符/ 逻辑运算符/ 位运算符/ 赋值运算符/ 条件运算符，除此之外，还有几个特殊用途的运符，如数组下标运算符等。操作数可以是变量，常量或方法调用等
  1.操作数：有常量和变量之分，只有简单数据类型和String类型才有相应的常量形式，变量是存储数据的基本单元，它可以用作表达式中的操作数，变量在使用之前要先声明。
  有时把类类型的变量称为引用。在声明变量的同时给变量赋了初值，称为对变量进行了初始化。 声明变量的地方有两处，一处是在方法内，另一处是在类定义内。方法内定义的变量称为自动变量，也称为局部变量、临时变量或栈变量。类中定义的变量是类的成员变量。
  Java程序中不允许将未经初始化的变量用作操作数。
  变量作用域：变量的作用域是值可访问该变量的代码范围。类中定义的成员变量的作用域是整个类。方法中定义的的局部变量的作用域是从该变量的声明处开始到包含该声明的语句块结束处，块外是不可用的。
  
  2.运算符
  2.1 算术运算符：算术运算符包括通常的加(+)、减(-)、乘(*)、除(/)、取模(%),完成整型和浮点型数据的运算。许多语言中的取模运算符只能用于整型数据，Java对此有所拓展，它允许对浮点数进行取模操作，例如 15.2 % 5 的结果是 0.2，取模还可以用于负数，结果的符号与地一个操作数符号相同。
  此外，算术运算符还有“++”和“--”自增和自减运算符，这两个运算符有前缀形式和后缀形式，++i和i++的执行顺序不一样，++i在i使用之前先加1,i++在i使用过后再加1,--i和i--的情况与此类似。
  
  2.2 关系运算符：关系运算符用来比较两个值，包括大于(>)、小于(<)、大于等于(>=)、小于等于(<=)、等于(==)和不等于(!=)6种。关系运算符都是二元运算符，也就是每个运算符都带有两个操作数。运算的结果是一个逻辑值。
  Java允许“==”和“！=”两种运算用于任何数据类型。例如，可以判断两个实例是否相等。
  
  2.3 逻辑运算符：逻辑运算符包括逻辑与(&&)、逻辑或(||)、逻辑非(!)。前两个是二元运算符，后一个是一元运算符。
  
  2.4 位运算符：位运算符用来对二进制位进行操作，包括按位取反(~)、按位与(&)、按位或(|)、异或(^)、右移(>>)、左移(<<)、及无符号右移(>>>)。位运算符只能对整型和字符型数据进行操作。运算在八位二进制下进行。
  Java提供两种右移运算符。运算符“>>”执行算术右移，它使用最高位填充移位后左侧的空位。右移的结果为：每移一位，第一个操作数被2整除一次，移动的次数由第二个操作数确定。
  逻辑右移运算符(也称为无符号右移运算符) >>>只对位进行操作，而没有算术含义，它用0填充左侧的空位。算术右移不改变原数的符号，而逻辑右移不能保证这一点。
  
  2.5 其他运算符：Java中的运算符还包括拓展赋值运算符(+=、-=、*=、/=、%=、&=、|=、^=、>>=、<<=和>>>=）、条件运算符(?:)、点运算符(.)、实例运算符(instan-ceof)、new运算符及数组下标运算符([])等。
  条件运算符(?：)是三元运算符，它的一般形式为：逻辑表达式 ? 语句1：语句2;  其中逻辑表达式得到一个逻辑值，根据该值的真假决定执行后续操作。逻辑值为真执行语句12,否则执行语句2。语句1和语句2需返回相同类型的值，且不能为void。
  
  2.6运算符的优先次序：在对一个表达式进行运算时，如果表达式中含有多种运算符，则要按运算符的优先次序依次从高到低进行，同级别的运算符则根据结合律自左向右或自右向左进行。括号可以改变运算次序。
  
  3.表达式的提升和转换：
  Java是一种强类型语言，不支持变量类型间的自动任意转换，有时必须显式地进行变量类型的转换。不同类型的数据先转换为同类型然后再进行运算。转换的一般原则是位数少的类型转换为位数多的类型，这称为自动类型转换。这样做的目的是保证转换时不丢失有用信息。
  能够进行自动类型转换的类型顺序为：byte、short、char、int、long、float、double。排在前面的类型可自动转换为排在后面的类型
第二章小结：本章介绍了Java程序的一些基本语法知识，包括空白、注释、关键词及标识符、数据和表达式等。着重介绍了Java语言命名标识符规则，列出了所有的关键字。介绍了8种基本数据类型，包括表示它们的关键字，各类型的表示范围，各类型常量值的含义、转义符的含义等。
本章还介绍了运算符的含义及其优先级，变量的声明、初始化、赋值方法及其作用域、Java表达式的表示方法、表达式提升和转换方法也是本章的重点。
   
   
第三章 流程控制语句：
第一节、Java程序的结构：
  一个Java程序可以由一个或多个.java文件组成，这些文件称为源文件。每个源文件中含有一个或多个类或接口。一个源文件中如果有多个类，则最多只能有一个是public类型的类，且该源文件的名字则为这个公有类的名字，且大小写一致。其他非public的类的个数不限。
  一个Java程序的结构包含以下内容：
   package语句：  包语句，每个文件最多只有一个，且必须放在文件开始的地方。
   import语句：  引入语句，可以没有，也可以有多个，如果有import语句的话，必须放在所有类定义的前面。
   具有public权限的类定义：  每个文件中最多有一个。
   类定义：  每个文件中包含的非public权限的类定义的个数没有限制。
   接口定义：  每个文件中包含的接口定义个数没有限制
  
  1.1 Java包的概念
  包是类的容器，包的设计人员利用包来划分名字空间，以避免类名冲突。Java中的包一般均包含相关的类，使用包的目的就是将相关的源代码文件组织到一起。
  程序中如果有package语句，该语句一定是源文件中的第一条非注释语句，它的前面只能有注释或空行。另外，一个文件中最多只能有一条package语句。包的名字有层次关系，各层之间以点分隔。
  
  1.2 引入语句
  假设已定义如下的包：
  package mypackage;
  public class MyClass {....}
  如果其他人在其他包中想使用MyClass类，则需要使用全名，如： mypackage.MyClass m = new mypackage.MyClass();
  为了简化程序的书写，Java提供了引入语句。当需要使用其他包中的类时，可以使用import语句引入需要的类，程序中无需在使用全名，语句简写为：import mypackage. *; MyClass m = new MyClass();
  从系统的角度来看，包名也是类名的一部分。包中类的名字“全称”是包名加类名。所以虽然不同的包中可能存在相同名称的类，但因为它们不在同一个包中，故类名还是不同的，从而可以尽最大可能避免名称冲突。从另一个角度看，这种机制提供了包一级的封装及存取权限。
  
第二节、流程控制
  Java程序中的语句指示计算机完成某些操作，一条语句的操作完成后会把控制转给另一条语句。语句是Java的最小执行单位，语句间以分号(;)作为分隔符。语句分为单语句及复合语句，单语句就是通常意义下的一条语句;而复合语句是一对大括号{}括起来的语句组，也称为“块”。
  2.1.赋值语句
  在Java程序中，表达式可以当作一个值赋给某个变量，这样的语句称为赋值语句。有的表达式也可单独当作语句，这样的语句称为表达式语句。	
  
  2.2 分支语句
  分支语句根据一定的条件，动态决定程序的流程方向，从程序的多个分支中选择一个或几个来执行。分支语句有if语句和switch语句两种。
  if语句：if语句是单重选择，最多只有两个分支。基本格式为： if(条件表达式) {语句1;} else {语句2;} 
  if关键字之后的条件表达式必须得到一个逻辑值，不能向其他语言那样用数值来代替。因为Java不提供数值与逻辑值之间的转换。
  if语句的三种常见形式：形式1，没有else子句。形式2,包含else语句。形式3,嵌套的if语句。
  
  switch语句：使用if语句可以实现简单的分支判断，并进而执行不同的语句。为了更方便地实现多重分支，Java语言还提供了switch语句，它的含义与嵌套if语句类似，只是格式上更加简洁。语法格式如下：
  switch (表达式) {
  		case c1：
  			语句组1;
  			break;
  		case c2：
  			语句组2;
  			break;
  } 这里，表达式的计算结果必须是int或char型，即是int型赋值相容的。当用byte或者short型时，要进行提升。Java规定switch语句不允许使用浮点型或long型表达式。c1，c2是int型或字符串型常量。default子句是可选的，
  switch语句的语义是：计算表达式的值，用该值依次和c1,c2相比较。如果该值等于其中之一则执行后面的语句组，直到遇到break语句跳到switch之后的语句。如果没有相匹配的case，则执行default之后的语句组。
  可以将default语句看作一个分支，即前面的条件均不满足时执行default。
  
  3.循环语句
  循环语句控制程序流多次执行一段代码。Java语言提供3种循环语句，分别是for语句、while语句和do语句。
  3.1 for(初始语句;条件表达式;迭代语句){
  		循环体语句;
  } //初始语句和迭代语句中可以包含有多个语句，各语句间以逗号分隔。for语句括号内的3个部分都是可选的，条件表达式为空时，默认规定为恒真。
  for语句的语义是：先执行初始语句，判断条件表达式的值，当条件表达式为真时，执行循环体语句，再执行迭代语句，然后去判别条件表达式的值。这个过程一直进行下去，知道条件表达式的值为假时，循环结束，转到for之后的语句继续执行。
  如果条件表达式的值永远为真，则循环会无限制的执行下去，直到系统资源消耗尽为止。比如for(;;){System.out.println("Always print!");}
  
  3.2 while语句：
  for语句中常常用循环控制变量显式控制循环的执行次数。当程序中不能明确地指明循环的执行次数时，可以仅用条件表达式来决定循环的执行与否。这样的循环用while来实现：
  while(条件表达式)：
    循环体语句;
  和if语句一样，while语句中的条件表达式亦不可用数值来代替。
  while语句的语义：计算条件表达式的值，当值为真时，重复执行循环体语句，直到条件表达式为假时结束。如果第一次检查时条件表达式为假，则循环体语句一次也不执行。如果条件表达式始终为真，则循环不会终止。
  
  3.3 do语句：
  do语句与while语句很相似。它把while语句中的条件表达式移到循环体之后。
  do语句的语法结构：
  	do：
  		语句：
  	while(条件表达式);
  do语句的语义是:首先执行循环体语句，然后判断条件表达式的值，当值为真时，重复执行循环体语句，直到表达式的值为假时结束循环。不论条件表达式的值是真是假，do循环中的循环体至少执行一次。
  
  4.跳转语句：
  	Java抛弃了有争议的goto语句，代之以两条特殊的流控制语句：break和continue语句，它们用在分支语句或循环语句中，更方便的控制程序执行的方向。
  4.1 标号：
  标号可以放在任意语句之前，通常与for、while或do语句配合使用，其语法格式为：
  标号：语句;
  
  4.2 break语句：
  break语句可用于3类语句中，第一类是在switch语句中，第二类实在for、while及do等循环语句中，第三类是在语句块中。在switch语句及循环语句中，break的语义是跳过本块中余下的所有语句，转到快尾，执行其后的语句。
  循环语句中的break为跳过余下的语句，结束循环。break语句的第三种使用方法是在块中和标号配合使用，其语法格式为：
  int x = 20;
  out: for(;;) {
  		if(x == 20) break out;
  }
  System.out.println("after out block");
  在上述案例中，当if语句条件满足时，跳出out标记的循环，执行块后的语句，即执行输出语句，显示“after out block”。
  
  4.3 continue语句：
  在循环语句中，continue语句可以立即结束当次循环，开始执行下一次循环，当然执行前需要先判断循环条件是否满足。
  continue语句也可以和标号一起使用，其语法格式为： continue 标号;
  它立即结束标号标记的那重循环的当次执行，开始下一次循环。这种形式的语句可以用在多重循环中。
 
第三节、简单的输入/输出
  程序运行期间交互式地读入用户的输入并将计算结果返回给用户是一个基本要求。本节介绍Java提供的用于输入/输出的几个基本类。
  1.Scanner类
  Scanner类属于Java.util包。它提供了许多方法，可用来方便地读入不同类型的输入值。可查阅相关的API文档来详细了解。
  要调用Scanner类的方法，必须先创建一个对象。Java中使用了new运算符来创建，语句如： Scannner scan = new Scanner(System.in);
  在创建Scanner类的对象时，构造方法接收一个参数，这个参数代表了输入源。System.in对象代表标准输入流，默认指键盘。
  Scanner对象用空白(空格，水平制表符及回车换行符)作为输入的分隔元素。这些空白成为分隔符。也可以指定用其他符号作为分隔符。
  Scanner类的next()方法读入下一个输入对象，将它作为字符串返回。如果输入的是一串用空白分开的多个字，则每次调用nex()都会得到下一个字。nextLine()方法读入当前行的所有输入，直到行尾，然后作为字符串返回。
  Scanner类的不同方法，如nextInt()和nextDouble()，用来读入不同类型的数据。输入的数值类型必须与所声明的变量类型要赋值兼容。
  
  2.NumberFormat类和DecimalFormat类
  NumberFormat类提供对数值进行格式化操作的一般功能。不能使用new运算符实例化一个NumberFormat对象，只能直接使用类名调用一个特殊的静态方法来得到一个对象。
  比如： NumberFormat类中的getInstance()方法返回当前默认语言环境的默认数值格式，然后使用格式对象来调用format()方法，将参数按相应的模式格式化后作为字符串返回。
  String myString = NumberFormat.getInstance().format(myNumber);
  和NumberFormat类不一样，DecimalFormat类按惯例使用new运算符来实例化对象。它的构造方法要带一个String类型的参数，这个参数表示格式化处理模式。

第四节、处理异常
  Java语言把程序运行中可能遇到的错误分为两类，一类是非致命性的，通过某种修正后程序还能继续执行。这类错误称为异常(Exception)。如打开一个文件时，发现文件不存在。又比如说除0溢出、数组越界等。这一类错误可以借助程序员的处理来恢复。
  另一类是致命性的，即程序遇到了非常严重的不正常状态，不能简单地恢复执行，这就是错误。比如程序运行过程中内存耗尽。异常处理要考虑的问题包括：如何处理异常？把异常交给谁去处理？程序又该如何从异常中恢复？
  
  1. 异常及处理机制：
  为了解决异常问题，Java提供了异常处理机制，预定义了一个Exception类。当程序中发生异常时，通常不是简单地结束程序，而是转去执行某段特殊代码来处理这个异常，设法恢复程序继续执行。但是如果程序遇到错误时，往往不能从中恢复，因此最好的办法是让程序中断执行。
  在一个方法的运行过程中，如果发生了异常，称程序产生了一个异常事件，相应地生成异常对象。该对象可能由正在运行的方法产生，也可能由JVM生成。这个对象中包含了该异常必要的详细信息,包括所发生的异常事件的类型及异常发生时程序的运行状态.
  生成的异常对象传递给Java运行时系统,运行时系统寻找相应的代码来处理这个异常. 生成异常对象并把它提交给运行时系统的这一过程称为抛出(Throw)一个异常.
  Java运行时系统从生成对象的代码块开始进行回溯,沿方法的调用栈逐层回溯,寻找相应的处理代码,直到找到包含相应异常处理的方法为止,并把异常对象交给该方法处理. 这一过程称为捕获(Catch). 当发现并相应异常时,就是处理(Handle)了异常。
  简而言之，发现错误的代码可以“抛出”一个异常，程序员可以“捕获”该异常，如果可能则“处理”它，然后恢复程序的执行。

  2. 异常分类：
  Java语言在所有的预设包中都定义了异常类和错误类。Exception类是所有异常类的父类，Error类是所有错误类的父类，这两个类同时又是Throwable类的子类。虽然异常属于不同的类，但所有这些类都是标准类Throwable的后代。
  Throwable在Java类库中，不需要import语句就可以使用。异常分为三种：{ 1.受检异常，必须被处理。 2.运行时异常，不需要处理。 3.错误，不需要处理。}
    1.受检异常(Checked Exception)是程序执行期间发生的严重事件的后果。例如，如果程序从磁盘中读入数据，而系统找不到含有数据的文件，将会发生受检异常。这个异常所属类的类名是FileNotFoundException。发生错误的原因可能是文件丢失等等，写的好的程序通常都会预见这种问题并处理。
    Java类库中的所有类都是使用名字来描述异常原因的。这些类表示受检异常: ClassNotFoundException / FileNotFoundException / IOException / NoSuchMethodException 及 WriteAbortedException.
  
    2.运行时异常(Runtime Exception)通常是程序逻辑错误的结果。例如，数组下标越界导致ArrayIndexOutOfBounds异常。被0除导致ArithmeticException异常。虽然可以添加代码来处理运行时异常，但一般只需要修改程序中的错误即可。
    运行时异常的所有类都是类RuntimeException的子类，它是Exception的后代。
    Java类库中的这些类表示运行时异常: ArithmeticException /  ArrayIndexOutOfBoundsException / ClassCastException / EmptyStackException / IllegalArgumentException / IllegalStateException / indexOutofBoundsException / NoSuchElementException / NullPointerException 和 UnsupportedOperationException

    3.错误(Error)是标准类Error或其后代类的一个对象, Error是Throwable的后代。一般地，错误是指发生了不正确的情况，如内存溢出。这些情况都比较严重，一般程序很难处理。所以，即使处理错误是合法的，一般也不需要处理它们。
    运行时异常和错误称为不检异常(Unchecked Exception)。
  有些异常类在使用时必须要引入。例如，当在程序中使用IOException时，必须要使用import java.io.IOException;

  3.处理异常：
  当发生异常时，程序通常会中断执行，并输出一条信息。对所发生的异常进行处理的就是异常处理。异常处理的重要性在于程序不但能发现异常，还要能捕获异常。对于可能引发受检异常的方法，有两种选择：在方法内处理异常，或时告诉方法的调用者来处理。
  比如，方法method1 调用 method2，method2又调用method3，进而method3又调用method4。在方法method4中如果出现异常，则在调用栈中的任何一个方法都可以捕获并处理这个异常。
  要处理异常，必须先标出可能引起异常的Java语句，还必须决定要找哪个异常。处理异常的代码含有两段。第一段try块含有可能抛出异常的语句。第二段含有一个或多个catch块。每个catch块含有捕获及处理某中类型异常的代码。
  catch(IOException e)标识符 e 称为catch块参数，它表示catch块将要处理IOException对象。参数e表示一个实际的异常。作为一个对象，每个异常都有存取方法getMessage()，它返回抛出异常时创建的描述字符串。通过显示这个字符串可知所发生异常的性质。
  catch块执行完毕，执行它后面的语句。但是如果问题很严重，则catch块可以调用exit方法来中止程序，如 System.exit(0); 赋给函数System.exit的参数0，表示虽然遇到了一个严重问题，但程序是正常结束的。
  单一一个try块中的语句，可能会抛出不同类型异常中的任意一个。在这样的try块后的catch块需要能捕获多个类的异常。为此，可以在try块后写多个catch块。当抛出一个异常时，为了能使所写的catch块真正捕获到相应的异常，catch块出现的次序很重要。程序的执行流程进入到其参数与异常类型相匹配的第一个catch块 ———— 按照出现的次序
  例如，下列的catch块次序不好，因为用于FileNotFoundException的catch块永远不会被执行：
  catch(IOException e) { .... } 
  catch(FileNotFoundException e) { .... }
  按照这个次序，任何I/O异常都被第一个catch块捕获。因为FileNotFoundException 派生于IOException，所以FileNotFoundException异常是IOException异常的一种，将与第一个catch块的参数相匹配。幸运的是，编译程序可能会对这样的次序给出警告信息。
  正确的次序是：
  catch(FileNotFoundException e) { .... } 
  catch(IOException e) { .... }  //处理所有其他的IOException
  因为受检异常和运行时异常的类都以Exception为祖先，故应避免在catch中使用Exception，而是尽可能地捕获具体的异常，且先捕获最具体的。
  try-catch的语法格式如下：
  try {
    //可能抛出异常的代码
  } catch (异常类型1 e) {
    //抛出异常类型1时要执行的代码，可能包含：
    System.out.println(e.getMessage());
  } catch (异常类型2 e) {
    //抛出异常类型2时要执行的代码，可能包含：
    System.out.println(e.getMessage());
  } finally {
    // 必须执行的代码
  }
  其中，异常类型1、异常类型2是产生的异常类型。根据发生异常所属的类，找到相应的catch语句，然后执行其中的语句。尽量避免在try块或catch块中再嵌套try-catch块；
  不论是否捕获异常，都要执行finally后的语句。一般地，为了统一处理程序出口，可将要处理的内容放到finally后的代码段中。
  try后的大括号中的代码称为保护代码。如果在保护代码内执行了System.exit()方法，将不在执行finally后面的语句，这是不执行finally后面语句的唯一一种可能。

  4.公共异常：
  为了方便处理异常，Java预定义了一些常见的异常，下面列举几个常用到的异常。
  1.ArithmeticException
  整数除法中，如果除数为0，则发生异常，如这个表达式将引发ArithmeticException异常：int i = 12/0;
  2.NullPointerException
  如果一个对象还没有实例化，那么访问该对象或调用它的方法将导致NullPointerException异常。例如：
  image im [] = new image[4];
  System.out.println(im[0].toString());
  第一行创建了有4个元素的数组im，每个元素是image类型，系统为其进行初始化，每个元素的值为null，表明它还没有指向任何实例。第二行要访问im[0]，由于访问的是还没有进行实例化的空引用，因此会导致NullPointerException。
  3.NegativeArraySizeException
  按常规，数组的元素个数应是一个大于等于0的整数。创建数组时，如果元素个数是负数，则会引发NegativeArraySizeException异常。
  4.ArrayIndexOutOfBoundsException
  Java把数组看作是对象，并用length变量记录数组的大小。访问数组元素时，运行时环境根据length值检查下标的大小。如果数组下标越界，则将导致ArrayIndexOutOfBoundsException异常。

  5.抛出异常：
  Java要求如果一个方法确实引发了一个异常(当然Error或RuntimeException两类错误除外)，那么在方法中必须写明相应的处理代码。
  处理异常有两种方法。一种是try块和catch块，捕获到所发生的异常类，并进行相应的处理。当然，catch块可以为空，表示对发生的异常不进行处理。
  另一种方法是，不在当前方法内处理异常，而是把异常抛出到调用方法中。当不能使用合理的方式来解决不正常或意外事件的情形下，才抛出异常。
  方法内执行throw语句时会抛出一个异常，一般形式如：throw exception_object;
  throw语句创建了一个异常对象 exception_object ，如： throw new IOException(); 这个语句创建类IOException的一个新对象并抛出它。抛出异常类型时也应该尽可能地具体。
    相应地，在说明方法时，要使用这个格式： 访问权限修饰符 返回值类型 方法名(参数列表) throws 异常列表
    紧接在关键字throws后面的是该方法内可能发生且不进行处理的所有异常列表。各异常之间用逗号分隔。例如：public void troubleSome() throws IOException
    一般地，如果一个方法引发了一个异常，而它自己又不处理，就要由调用者方法进行处理。如果方法内含有一个抛出异常的throw语句，则要在方法头添加一个throws子句，而不是在方法体内捕获异常。一般地，抛出异常及捕获异常应该在不同的方法内。
    在方法头中用Java保留字throws来声明这个方法可能抛出的异常；在方法体中用保留字throw实际抛出一个异常。  注意，这两个保留字不要混淆；

第三章小结：包是Java大的独特概念，与此相关的语句包括package语句和import语句。
本章详细介绍了各主要语句的语法格式，使用它们可以编写出基本的程序。此外还介绍了简单的输入/输出语句。
要编写稳定性强的程序，必须对可鞥出现的错误进行处理。Java提供了异常处理机制，本章详细介绍了异常处理的概念及处理机制，包括try、catch、finally、throw 和 throws 的使用方法。介绍了预定义的若干异常，以及编写程序时要注意的事项。


第四章 面向对象程序设计：
第一节、类和对象：
  1.类的定义：
  类的定义也称为类的声明。类中含有两部分元素，分别是数据成员变量和成员方法。类定义的一般格式如下：
  修饰符 class 类名 [extends 父类名] {
    修饰符 类型 成员变量1;
    修饰符 类型 成员变量2;
    ......
    修饰符 类型 成员方法1(参数列表) {
      方法体
    }
    修饰服 类型 成员方法2(参数列表) {
      方法体
    }
    ......
  }
  其中,class是关键字,表明其后定义是一个类. 含有class这一行称为类头,后面大括号括住的部分称为类体. class前的修饰符可以有多个,用来限定所定义的类的使用方式. 类名是用户为该类所起的名字,它必须是一个合法的标识符,并尽量遵从命名约定.
  extends是继承关键子. 如果所定义的类是从某个父类派生而来,那么,父类的名字要写在extends之后。 类定义中的数据成员变量可以有多个。成员变量前面的类型是该变量的类型；类中的成员方法也可以有很多个，其前面的类型是该方法返回值的类型。如果没有返回值，则写void。方法体是要执行的真正语句。
  在方法体中还可以定义该方法内使用的局部变量，这些局部变量只在该方法内有效。方法的参数列表中可以含有0个或多个参数，每个参数的前面要指明该参数的类型。 类定义中的修饰符是访问权限修饰符，包括public,private和protected, 也可以不写，表示是默认修饰符。
  它们既可以用来修饰类，又可以修饰类中的成员，修饰符决定所修饰成员在程序运行时被访问的方式。具体来说，用public修饰的成员表示是公有的，也就是它可以被其他任何对象访问。类中限定为private的成员只能被这个类本身访问，在类外不可见。用protected修饰的成员是受保护的，只可以被同一个包及其子类的实例的对象访问。
  如果不写任何修饰符，则表明是默认的，相应的成员可以被所在包中的各类访问。
  关于类定义，总结如下：
  ①类定义中，类头与类体是放在一起保存的，整个类必须在一个文件中，因此有时源文件会很大。
  ②源文件名必须根据文件中的公有类名来定义，并且要区分大小写。
  ③类定义中可以指明父类，也可以不指明。若没有指明是从哪个类派生而来，则表明是从默认的父类Object派生而来。实际上，Object是Java所有类的直接或间接父类。Java中除Object之外的所有类均有一个且只有一个父类。Object是唯一没有父类的类。
  ④class定义的大括号之后没有分隔符 ";" 

  2.构造方法：
  构造方法是一类特殊的方法，有特殊的功能。构造方法的名字与类名相同，没有返回值，在创建对象实例时通过new运算符自动调用。同时为了便于创建实例，一个类可以有多个具有不同参数列表的构造方法，即构造方法可以重载。事实上，不论是系统提供的标准类，还是用户定义的类，往往都含有多个构造方法。
  例如：
  public class Xyz {
    int x;   // 成员变量
    public Xyz() { x = 0; } // 参数列表为空的构造方法
    public Xyz(int i) { x = i; } // 第一个参数的构造方法
  }
  在类Xyz中定义了两个构造方法，第一个方法的参数列表是空的，第二个方法带有一个int类型参数。在创建Xyz的实例时，可以使用下列两种形式：
  Xyz obj =  new Xyz(); // 使用第一个构造方法
  Xyz obj2 = new Xyz(5); // 使用第二个构造方法
  构造方法不能说明为native，abstract，synchronized或final类型，通常说明为public类型。构造方法不能从父类继承。另外，构造方法没有返回值。一般来说，构造方法应该为所有的成员变量赋初始值，成员变量的值亦称为对象的属性值。
  默认的构造方法：每个类必须至少有一个构造方法。如果程序员没有为类定义构造方法，系统就会自动为该类生成一个默认的构造方法。默认构造方法的参数列表及方法体均为空，所生成的对象的各属性也为零或空。如果类定义中已经含有一个或多个构造方法，则系统不会再自动生成默认的构造方法了。
  构造方法重载： 在进行对象实例化时可能会遇到许多不同情况，于是要求针对所给定的不同的参数，调用不同的构造方法。这时，可以通过在一个类中同时定义若干个构造方法，亦即对构造方法进行重载来实现。
  有些构造方法中会有重复的代码，或者一个构造函数可能包含另一个构造方法中的全部代码，为了简化代码，可以在其中一个构造方法中引用另一个构造方法。可以使用关键字this来指代本类中的其他构造方法。
  例如：构造方法的重载及引用
  public class Student {
    String name;
    int age;
    public Student(String s, int n) {  // 构造方法1
      name = s;
      age = n;
    }
    public Student(String s) { // 构造方法2
      this(s , 20);
    }
    public Student() { // 构造方法3
      this("Unknown");
    }
  }
  在上面的示例中，第三个构造方法中没有任何参数，它调用this("Unknown"),实际上是把控制权转给了只带一个字符串参数的第二个构造方法，并为其提供了所需的字符串参数值"Unknown"。而第二个构造方法中，则通过调用this(s , 20),把控制权转给第一个构造方法，并为其提供了字符串参数"Unknown"和int类型参数的值20。
  this引用： this除了可以用在构造方法中之外，还可以用来指明要操作的对象本身。

  3.对象的创建和初始化
  实际上，类的定义相当于一个“模子”，声明一个个类类型变量的过程就像是拿着模子复制一个个的副本，程序中使用的就是这样的一个个对象。
  以上面的Student类为例，现在可以声明Student类型的变量：Student myObj; 
  声明变量后，在内存中为其建立了一个引用，此时它不指向任何内存空间。对象的引用也称为对象的句柄。之后需要使用 new 申请相应的内存空间，内存空间的大小依class的定义而定，并将该段内存的首地址赋给刚才建立的引用。
  换句话说，用class类型声明的变量并不是数据本身，而只是对数据的引用，要用new来进一步创建类的实例或叫对象本身。比如： myObj = new Student(); 调用 new 为新对象分配空间，就是要调用类的构造方法。
  在Java中，使用构造方法是生成实例对象的唯一途径。这个过程称为对象的实例化。说明一个引用变量仅仅只是预定了变量的存储空间，此时并没有相应的地址空间给实例使用。必须进行对象实例化之后，才有真正的实例出现。在调用new时，是否带有参数、带多少个、各是什么类型的参数，要视具体的构造方法而定。系统根据所带参数的个数和类型，调用相应的构造方法。
  类X的一个对象也称为类X的一个实例。创建对象实例的格式： 类名 对象名称 = new 类名(参数列表);
  当通过new为一个对象分配内存时，如果构造方法中没有为成员变量提供初始值，则Java进行自动初始化。对于数值变量，赋初值0；对于布尔变量，赋初值false；对于引用，即对象类型的任何变量，使用一个特殊的值null作为初值。最常用的初始化过程是使用new对对象进行实例化。
  以Date为例，以下描述了从类引用声明到创建实例的过程。
                            ————————————
  Date today     today     |    ????    |    声明引用
                            ————————————
  .....................................................
  today = new Date();       ————————————
                 day       |    0       |   
                 month     |    0       |  ⬅ ——
                 year      |    0       |       |  创建对象类的实例
                            ————————————        |
                                                |    
                today       ————————————        |
                           | 0x01abcdef |  —— ——
                            ————————————
  声明了today后，它的内存中没有存放任何值(上图中表示为????)。只当实例化后，也就是指向了new Date()语句后，才在内存中分配了Date实例的地址，并在相应的3个成员变量内存中存放了初值0.同时将这个实例的首地址存放的引用today内。
  给定类Xxx的类定义，调用new Xxx()创建的每个对象都区别于其他对象，并有自己的引用。该引用存储在相应的类变量中，然后也可以使用点操作符来访问每个对象中的各独立成员。
  使用对象中的数据和方法的格式如下：
    对象引用.成员数据
    对象引用.成员方法(参数列表);
  因为引用的特殊性，故给引用赋值时，它的含义与基本类型变量的赋值不一样。引用的赋值时将句柄赋值给另一个引用，它们都是指向同一个内存堆，所以它们的数值都是一样的。
  在Java中，null值表示引用不指向任何对象。程序运行过程中系统若发现使用了这样一个引用时，可以立即停止进一步的访问，不会给系统带来任何危险。

第二节、定义方法：
  1.方法的定义：
  对对象的操作体现在成员方法上。说明为private的成员变量，在类外，不能通过点操作符直接访问，必须通过成员方法才能访问。一般来讲，成员变量应尽量声明为private的，同时提供一组相关的访问方法供其他类使用。
  在Java中，方法定义的一般格式如下：
    修饰符 返回类型 方法名(参数列表) 块
    关于方法定义的说明如下。
    ①方法名必须是一个合法的标识符。
    ②返回类型是方法返回值的类型。如果方法不返回任何值，则应声明为void。Java对待返回值的要求很严格，方法返回值必须与所声明的类型相匹配。如果方法声明有返回值，比如说int，那么方法从任何分支返回时都必须返回一个整数值。
    ③修饰符段可以含有几个不同的修饰符，其中限定访问权限的修饰符包括public、private和protected。
    ④参数列表是传送给方法的参数表。表中各元素以逗号分隔，每个元素由一个类型和一个标识符表示的参数组成。
    ⑤块表示方法体，是要实际执行的代码段，是由一对大括号括起来的语句序列。方法体中一般使用return语句表示方法的结束。如果方法的返回类型不是void，则需要在return语句中指明方法的返回值。
  
  2.按值传送
  调用方法时，通常会给方法传递一些值。传给方法的值称为实参，方法的参数列表中列出的值称为形参。
  Java“按值”传送实参。如果形参是基本数据类型的，则调用方法时，将实参的“值”复制给形参。返回时，形参的值并不会带回给实参，即在方法内对形参的任何修改，都不会影响实参的值。
  如果形参是引用，则调用方法时传递给形参的是一个地址，即实参指向的对象的首地址。方法返回时，这个地址也不会被改变，但是地址内保存的内容是可以改变的。因此，当从方法中退出时，所修改的对象内容可以保留下来。

  3.重载方法名
  允许多个方法使用同一个方法名，这就是方法名的重载(Overload)。一个类中，如果有多个方法的名字是一样的，为了在调用时不产生混乱，Java规定，方法的参数列表必须不完全相同。实际上，Java正是根据参数列表来查找适当的方法并进行调用的，这其中包括参数的个数及各参数的类型以及它们的顺序。
  一般地，方法名称加上方法的参数列表(包括方法中参数的个数、顺序和类型)称为方法签名。方法重载时，方法签名一定不能相同。在一个类的定义中，往往会有多个构造方法，根据初始化时的不同条件调用不同的构造方法，以生成不同的对象。
  重载方法有两条规定，分别如下所述：
    ①调用语句的实参列表必须足够判断要调用的是哪个方法。实参的类型可能要进行正常的拓展提升(如浮点数变为双精度数)，但在有些情况下会引起混淆。
    ②方法的返回类型可以相应也可以不同。两个同名方法仅有返回类型不同，而参数列表完全相同，这是不够的，因为在方法执行钱不知道能得到什么类型的返回值，因此也就不能确定要调用哪个方法。重载方法的参数列表必须不同。
  
第三节、静态成员：
  在类的定义中还可以定义一种特殊的成员，用static修饰，称为静态成员或类成员，包括静态变量和静态方法。静态成员是不依赖于特定对象的内容。Java运行时中系统生成类的每个实例对象时，会为每个对象的实例变量分配内存，然后才可以访问对象的成员，而且不同对象的内存空间相互独立，也就是说对于不同对象的成员，其内存地址时不同的。
  但是如果类中包含静态成员，则系统只在类定义时为静态成员分配内存，此时还没有创建对象啊。也没有对对象进行实例化。以后生成该类的实例对象时，将不再为静态成员分配内存，不同对象的静态变量将共享同一块内存空间。
  1.静态变量：
    在程序设计中，有时一个变量会被类的多个实例对象所共享，以实现多个对象之间的通信，或用于记录已被创建的对象的个数等。静态变量也被称为类变量，以区别于成员变量或实例变量。将一个变量定义为静态变量的方法就是将这个变量标记上关键字static。
    在Java中没有全局变量的概念，静态变量从某种意义上来说相当于其他程序设计语言中的全局变量。静态变量是唯一为类中所有对象共享的变量。如果一个静态变量同时还被定义为public类型，那么其他类也同样可以使用这一变量。
    而且由于静态变量的内存空间是在类的定义时就已经分分配的，因此引用这一变量时甚至无需生成该类的一个对象，而是直接通过类名来指向它。

  2.静态方法：
    与静态变量类似，如果需要在尚未创建一个对象实例的时候就去引用方法的程序代码，那么标记上关键字static即可实现。这样的方法称为静态方法，或称类方法。与之相对的，非静态方法有时也称为实例方法。静态方法不依赖于特定对象的行为。
    调用静态方法时，前缀使用的是类名，而不是对象实例名。如果从当前类中的其他方法中调用，则不需要写类名，可以直接写方法名。
    使用静态方法时，有两个特别的限制必须注意：
    ①由于静态方法可以在没有定义它所属的类的对象的情况下加以调用，故不存在this值。因此，一个静态方法只能使用其内部定义的参数或静态变量，如果想使用非静态变量将引起编译错误。
      例：错误的引用
        public class Wrong {
          int x;                                // 非静态变量
          public static void main(Srting args[]) {
             x = 9;                             // 无法从静态方法中引用非静态变量x
           }
        }
    ②静态方法不能被重写。也就是说，在这个类的后代类中，不能有相同名称，相同参数列表的方法。 关于方法的重写，将在第六章讨论。

第四节、包装类：
  Java使用的基本数据类型(如int、double、char和boolean)及类和对象来表示数据。要管理的数据仅有两类，即基本数据类型值及对象引用。但当想用处理对象一样的方式来处理基本类型的数据时，必须将基本类型值“包装”为一个对象。为此，Java提供了包装类。
  包装类表示一种特殊的基本类型。例如，Integer类表示一个普通的整型量。由Integer类创建的对象只保存一个int型的值。
  包装类的构造方法接受一个基本类型的值，并保存它，例如：Integer ageObj = new integer(40); 执行这条语句后ageObj对象就将整数40看作一个对象。它可以用在程序中需要对象而不是需要基本类型值的地方。
  对于Java中的每种基本数据类型，Java类库种都有一个对应的包装类。所有的包装类都定义在java.lang包中,如下：
  byte: Byte;  short: Short;  int: Int;  long: Long;  float: Float;  double: Double;  char: Character;  boolean: Boolean;  void: Void;
  注意，对应于void类型的包装类是Void。但和其他的包装类不一样的是，Void类不能被实例化，只表示void引用的概念。

  调用静态方法时不依赖于任何的实例对象。以perseInt为例，它将保存在字符串中的值转为对应的int型值。如果字符串对象str中的值是“987”，则最后的代码将字符串转为整型量987，并保存在int型变量num中：num = Integer.paseInt(str);
  自动将基本数据类型转换为对应的包装类的过程称为自动装箱(Autoboxing)。例如：
    Integer obj1;
    int num1 = 69;
    obj1 = num1;      //自动创建Integer对象
  逆向的转换称为拆箱(Unboxing)，需要时也是自动完成的。例如：
    Integer obj2 = new Integer(69);
    int num2;
    num2 = obj2;    //自动解析出int型
  一般来说，基本数据类型与对象之间的赋值是不相容的。自动装箱与自动拆箱仅能用在基本数据类型与对应的包装类之间。其他的情况，如将基本数据类型赋给对象引用变量，或是相反的过程，都会导致编译错误。

第四章小结：Java是面向对象的程序设计语言，它为用户提供了类，接口和数组，这些都是不同于基本数据类型的类型。本章介绍如何定义一个类，如何声明一个对象并进行初始化，如何编写构造方法及类中的方法。本章还介绍了访问修饰符的含义及使用。这些是面向对象程序设计中最基本的内容。
本章介绍了方法的按值传松机制，介绍了方法的重载及方法签名的概念。此外还介绍了静态成员的含义及调用规则，介绍了包装类的概念及与之相关的自动拆箱与装箱。


第五章 数组和字符串
第一节、数组：
  1.数组声明：
    一个数组是相同数据类型的元素按一定顺序排列的集合。使用数组可以将同一类型的数据存储在连续的内存位置。数组中各元素的类型相同，通过下标来访问数组中的元素，下标从0开始。在Java中，数组是对象。类Object中定义的方法都能用于数组对象。
    程序员可以声明任何类型的数组，具体来说，数组元素可以是基本数据类型，也可以是类类型或接口类型，当然还可以是数组。数组在使用之前必须先声明，也就是要先定义后使用。一维数组的定义格式为：类型 数组名[]; 其中，类型是数组元素的类型。数组名为合法的标识符，[]指明定义的是一个数组类型变量。
    还可以定义类类型的数组，比如：Date dateArray[]; 这个声明的数组，其元素都是类类型的，dataArray的每个元素都是类型Date的。
    在数组定义时并不会为数组分配内存，因此方括号[]中不需要指出数组元素的个数，即数组长度。和其他类型一样，数组声明并不创建数组对象本身。所以这些声明没有创建数组。声明的数组名只是引用变量，用来指向一个数组。
    Java还允许用另一种格式来声明数组，格式为: 类型[] 数组名; 比如: int[] intArray; 这个声明与前面的声明完全等价，在这种格式中，左面是类型部分，右面是变量名，与其他类型声明的格式一致。
    Java中没有静态的数组定义，这种写法是错误的: int intArray[5];
  
  2.创建数组:
    数组声明仅仅是定义了一个数组引用，系统并没有为数组分配任何内存，因此现在还不能访问它的任何元素。必须经过数组初始化后，才能使用数组的元素。初始化的过程就是数组的创建过程。
    数组的初始化分为静态初始化和动态初始化两种。所谓静态初始化就是在定义数组的同时给数组元素赋初值。静态初始化使用一对大括号将初值括起来，每个元素对应一个引用。例如: int intArray[] = {1,2,3};
    动态初始化：
    String names[];
    names = new String[2];
    names[0] = "person1";
    names[1] = "person2";
    上述语句使用的是动态初始化，使用运算符new为数组分配空间，这和所有对象是一样的。数组声明的方括号中的数字表示数组元素个数。
    对于基本数组类型的数组，其创建格式如下：
    类型 数组名[] = new 类型[数组大小];
    类型[] 数组名 = new 类型[数组大小];
    如果前面已经对数组进行了声明，则此处的类型可以不写。比如已经定义了char[] s; 则s = new char[20]; 将创建有20个字符的数组s。
    对于类类型的数组，使用运算符new只是为数组本身分配空间，并没有对数组的元素进行初始化。所以对于类类型的数值，空间分配需要经过两步。
    第一步先创建数组本身:            类型 数组名[] = new 类型[数组大小] ;
    第二步分别创建各个数组元素：     数组名[0] = new 类型(初值表);
                                    ...
                                    数组名[数组大小-1] = new 类型(初值表);
    若有Point类定义如下:
    class Point {
      int x, y;
      Point(int x1, int y1) {
        x = x1;
        y = y1;
      }
      Point() {
        this(0 , 0);
      }
    }
    语句points = new Point[100]; 只创建了有100个Point型变量的数组。它没有创建100个Point对象。因为Point型是类类型。这些对象必须再单独创建，如：points[0] = new Point();  points[n] = new Point();
    数组变量的类型可以不同于所指向的数组类，但应该是它的祖先类。例如:
    Object[] points;
    points - new Point[100]; // 这是允许的
    points是Object类型的数组，第二行创建的数组是Point类型的，Point派生于公共父类Object。
    反之则是不允许的，例如：
    Point[] points;
    points = new Object[100]; // 不允许的

  3.访问数组元素：
    在Java中，数组下标从0开始，数组中的元素个数length是数组类中唯一的数据成员变量。使用new创建数组时系统自动给length赋值。数组一旦创建完毕，其大小就固定下来。程序运行时可以使用length进行数组边界检查。如发生越界访问，则抛出一个异常，
    在循环中使用length就不会引起数组下标越界，修改也更加方便。当定义了一个数组，并用运算符new为它分配了内存空间后，就可以引用数组中的每一个元素了。数组名加上下标可以表示数组元素，元素的引用格式为：数组名[下标] 其中，下标的范围是 0 ~ length-1。下标可以是整型常量或表达式。
    当创建一个数组时，每个元素都被初始化。如前面创建的字符数组s，它的每个值被初始化为0(\0000)。而数组points的每个值被初始化为null，表明它尚未指向真正的Point对象。在执行赋值语句: points[0] = new Point();后，系统创建一个真正的Point对象，并让数组的第一个元素指向它。
    注意，包括数组元素在内的所有变量的初始化，从系统安全角度看都是必不可少的，任何变量都不能在没有初始化的状态下使用。但不幸的是，编译器不能检查数组元素的初始化情况，所以需要程序员自己多加注意。
  
  4.多维数组
    4.1多维数组的定义：
     数组元素可以声明为任何类型，比如一维数组类型，这样可以建立数组的数组，即二维数组。推而广之，可以得到多维数组。一般来讲，n维数组是n-1维数组的数组。声明多维数组时使用类型及多对方括号。例如,int[][]是类型，表示二维数组，每个元素都是int类型。
     以二维数组为例，定义格式如下：
     类型 数组名[][];
     例如：int intArray[][]; 声明了二维数组intArray。
     也可采用另外两种定义方式。
     类型[][] 数组名;
     类型[] 数组名[];
     与一维数组一样，二维数组定义时对数组元素没有分配内存空间，同样要进行初始化后，才可以访问每个元素。

    4.2多维数组的初始化：
     与一维数组一样，多维数组的初始化也分为静态和动态两种。静态初始化时，在定义数组的同时为数组元素赋初值。例如二维数组intArray的初始化如：int intArray[][] = {{1,3} , {5,7}};
     这里，不必指出数组每个维的大小，系统会根据初始化时给出的初值的个数自动计算数组每个维的大小。外层括号所含各元素是数组第一维的各元素，内层括号对应于数组第二维的元素。上面这个intArray数组是一个[2][2]的数组。
     使用两个下标可以访问数组中的对应元素，如intArray[1][1]表示该数组第二行第二列的元素，它的值为7。注意，数组各维的下标均从0开始。
     对二维数组进行动态初始化时，有两种分配内存空间的方法：直接分配与按维分配。直接分配就是直接为每个维分配空间，声明数组时，给出各维的大小。仍以二维数组为例，格式如下：
     类型 数组名[][] = new 类型[数组第一维大小][数组第二维大小];
     例如：int intArray[][] = new int[2][3];声明了一个2行3列的二维数组。
     按维分配是从最高维起(而且必须从最高维开始),分别为每一维分配内存，创建二维数组的格式如下：
     类型 数组名[][] = new 类型[数组第一维大小][];
     数组名[0] = new 类型[数组第二维大小];
     数组名[1] = new 类型[数组第二维大小];
      ...
     数组名[数组第一维大小-1] = new 类型[数组第二维大小];
     如果创建数组时第二维大小是一样的，则创建的是一个矩阵数组。如下：
     int twoDim[][] = new int[4][];  // 创建一个4行的二维数组
     twoDim[0] = new int[5]; // 第一行有5列
     twoDim[1] = new int[5]; // 第二行有5列
     twoDim[2] = new int[5]; // 第三行有5列
     twoDim[3] = new int[5]; // 第四行有5列
     第一行的声明语句调用new创建了一个数组对象，且说明了第一维的大小(4)，此时数组的4个元素中各含有一个null引用。后续的4个声明语句分别让这4个元素指向各含5个元素的一维数组，由此构成了一个4行5列的二维数组。
     直接分配与按维分配的含义是相同的。例如：
     int matrix[][] = new int[4][5];
     等价于下面这段代码。
     int matrix[][] = new int[4][];
     for(int j = 0; j < matrix.length; j++) 
        matrix[j] = new int[5];
     虽然数组声明格式允许方括号在变量名的左面或右面使用，但在多维数组中使用时应注意其合法性。正确的及错误的二维数组声明如下：
     这是正确的：
     int a1[][] = new int[2][3];
     int a2[][] = new int[2][];
     int []a3[] = new int[4][6];
     下面是错误的：
     int errarr1[2][3]; // 不允许声明静态数组
     int errarr2[][] = new int[][4]; // 维度声明顺序应从高维到低维，先说明高维，在说明低维
     int errarr3[][4] = new int[3][4]; // 数组维度的指定只能出现在new运算符之后

    4.3多维数组的引用：
     在定义并初始化多维数组后，可以使用多维数组中的每个元素。仍以二维数组为例，引用方式为：数组名[第一维下标][第二维下标]
     数组下标也称为索引，它们都可以是整型常数和表达式，都是从0开始。第一维也称为行，第二维也称为列。例如，声明了数组myTable: int myTable[][] = new int[4][3];
     如果要访问myTable的元素，只需要指定相应的行、列下标就可以了。
     myTable[0][0] = 34;
     myTable[0][1] = 15;
     myTable[0][2] = 3 * myTable[0][1] + 11;
     二维数组也有length属性，但它只表示第一维的长度。例如：int ages[4][7]; 则ages.length的值为4，而不是28。
     可以分别存取每个维的长度，例如：
     int[][] ages = new int[4][7];
     int[] firstArray = ages[0]; // first.length = 7
     在Java中，数组是用来表示一组同类型数据的数据结构，并且数组是定长的，初始化后，数组的大小不会再动态变化。数组变量是一个指向数组对象实例的引用。
     数组创建后就不能再改变它的大小，但是可以使用同一个引用变量指向另一个全新的数组，例如: 
     int elements[] = new int[6];
     elements = new int[10];
     执行这两行语句后,elements指向第二个数组，第一个数组实际上丢失了，除非还有其他的引用指向它。
     可以使用一种高效率的方法复制数组。System类中提供了一个特殊的方法arraycopy()，它可以将一个数组中的元素复制到另一个数组中。arraycopy()方法的声明如下：
      public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
     其中，src表示源数组，srcPos表示源数组中的起始位置，dest表示目标数组，destPos表示目标数组中的起始位置，length表示要复制的数组元素的个数。
      例如，下面的代码将数组src中的前5个元素复制到数组dest中。
      int src[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
      int dest[] = {10, 11, 12, 13, 14, 15, 16, 17, 18};
      System.arraycopy(src, 0, dest, 0, 5);
      System.out.println("dest数组中的各个元素为：");
      for (int i = 0; i < dest.length; i++) {
         System.out.print(dest[i] + " ");
      }
      运行结果为：
      dest数组中的各个元素为：
      1 2 3 4 5 15 16 17 18
      从上面的运行结果可以看出，arraycopy()方法将src数组中的前5个元素复制到dest数组中，而dest数组中原来的前5个元素被覆盖了。

第二节、字符串类型：
  字符串是由有限个字符组成的序列，Java中的字符串是一个对象，而不是一个以'\0'结尾的字符数组。Java的标准包java.lang中封装了String类和StringBuffer类，其中String类是不可变的，而StringBuffer类是可变的。
  1.字符串的声明：
    字符串是内存中连续排列的0个或多个字符。不变字符串是指字符串一旦创建，其内容就不能改变。比如，对String类的实例进行查找、比较、连接等操作时，既不能输入新字符，又不能改变字符串的长度。对于那些需要改变内容并有许多操作的字符串，应该使用StringBuffer类。
    String类和StringBuffer类中都封装了许多方法，用来对字符串进行操作。
    Java程序中的字符串分为常量和变量两种，其中字符串常量使用双引号括起来的一串字符。系统为程序中出现的字符串常量自动创建一个String对象，例如：System.out.println("Hello World!"); 将创建"Hello World!"对象，这个创建过程是隐含的。
    对于字符串变量，在使用之前要显式声明，并进行初始化。字符串的声明很简单，例如：String s1;  StringBuffer sb1;
    也可以创建一个空的字符串：
    String s1 = new String();
    StringBuffer sb1 = new StringBuffer();
    此外，还可以由字符数组创建字符串，如右所示：char chars[] = {'a', 'b', 'c', 'd', 'e'};  String s2 = new String(chars);
    当然，可以直接用字符串常量来初始化一个字符串：String s3 = "Hello World!";
    StringBuffer类不能使用字符串常量来创建，比如：StringBuffer sb2 = "Hello World!"; 是错误的。但是可以使用String类的变量来创建，比如使用已经定义的s3来创建一个StringBuffer对象：StringBuffer strb3 = new StringBuffer(s3);

  2.字符串的操作：
    字符串创建之后，可以使用字符串类中的方法对它进行操作。
    String类的对象实例是不可改变的，一旦创建就确定下来。对字符串施加操作后并不改变字符串本身，而是又生成了另一个实例。
    StringBuffer类处理可变字符串，当修改一个StringBuffer类的字符串时，不是再创建一个新的字符串对象，而是直接操作原字符串。Java为两个类提供的方法不完全相同。
    String类和StringBuffer类中共有的常用方法如下：
     (1)、length(): 返回字符串的长度。  
     (2)、charAt(int index): 返回字符串中index位置的字符。
     (3)、subString(int beginIndex): 截取当前字符串中从beginIndex开始到末尾的子串。
    String类中常用的方法如下：
     (1)、replace(char oldChar, char newChar): 将当前字符串中出现的所有oldChar转换为new Char。
     (2)、toLowerCase(): 将当前字符串中所有字符转换为小写形式。
     (3)、toUpperCase(): 将当前字符串中所有字符转换为大写形式。
     (4)、concar(String str): 将str连接在当前字符串的尾部。
     (5)、startsWith(String prefix): 测试prefix是否是当前字符串的前缀。
     (6)、trim(): 去掉字符串前面及后面的空白。
     (7)、valueOf(type value): 将type类型的参数转换为字符串形式。
    StringBuffer类中的常用方法如下：
     (1)、append(String str): 将参数str表示的字符串添加到当前串的最后。
     (2)、replace(int start, int end, String str): 使用给定的str替换从start到end之间的子串。
     (3)、capacity(): 返回当前的容量。
    String类型字符串的连接还可以使用运算符+来实现。
    系统为String类对象分配内存时，按照对象中所含字符的实际个数等量分配。而为StringBuffer类对象分配内存时，除去字符串所占空间外，再另加16个字符大小的缓冲区。对于StringBuffer类对象，length()方法获得的是字符串的长度，capacity()方法返回当前的容量，即字符串长度再加上缓冲区大小。
    String类中有多个比较方法，如compareTo()、equals()、equalsIgnoreCase()、regionMatches()等，它们用于实现字符串的比较。方法的名字反映了它们的功能，这里不再详细介绍。
    此外，Java中也可以使用关系运算符"=="判断两个字符串是否相等。与equals() 方法不同的是，"=="判定两个字符串对象是否是同一实例，即它们在内存中的存储空间是否相同。

第三节、Vector类：
  与大多数程序设计语言一样，Java的数组只能保存固定数目的元素，数组空间一经申请就不可再改变，不能再追加数组的空间。为了解决这个问题，Java中引入了Vector(向量)类，可以看作是可变数组。
  1.概述：
    Vector是Java.util包提供的一个非常重要的工具类，它类似于数组，可以使用整数下标来访问各个元素，但是比数组的功能更强大。首先，它是变长数组，Vector实例的大小可以根据需要来改变。创建了Vector的对象后，如果增加或删除了其中的元素，则Vector的大小也相应地变大或变小。
    其次，保存的元素的类型可以不一样。因此可以看作是把不同类型的元素按照动态数组进行处理。Vector类的对象不但可以保存顺序的一列数据，而且还提供了许多有用的方法来操作和处理这些数据。
    当需要处理由数目不定、类型不同的对象组成的对象序列，或是需要频繁地在对象序列中进行插入/删除/查找操作时，通常使用向量来替代数组。但要注意，Vector类的实例中只能保存对象类型，而不能是基本数据类型，例如int类型。
    Vector类包含的成员变量有3个：
      (1)、protected intcapacityIncrement:  增量的大小。如果指为0.则缓冲区的大小每次倍增。
      (2)、protected intelementCount:       Vector对象中元素的数量。
      (3)、protected ObjectelementData[]:   元素存储的数组缓冲区。
    系统内部会记录Vector类实例的容量capacity，实际保存的元素个数有elementCount来记录，这个值不能大于容量值。当有元素加入到向量时，elementCount会相应增大。
    当向量中添加的元素超过了它的容量后，向量的存储空间以容量增值capacityIncrement的大小为单位增长，为以后新的元素加入做好准备。元素保存在数组elementData中。
  
  2.Vector类的方法：
    2.1构造方法
      常用的Vector类的3个构造方法如下：
        public Vector(): 创建一个空向量。
        public Vector(initnitialCapacity): 以指定的初始存储容量initialCapacity构造一个空的向量Vector。
        public Vector(initnitialCapacity, int capacityIncrement): 以指定的初始存储容量initialCapacity和增量capacityIncrement构造一个空的向量Vector。 
      创建Vector的实例时，要指明其中保存的元素的类型。例如: Vector<String> myVector = new Vector<String>(100,50); 创建的myVector向量序列初始有100个字符串的空间，以后一旦空间用尽则以50为单位递增，使序列中能够容纳的元素个数为150，200.....
    
    2.2添加方法
      向Vector类对象中添加元素的常用方法如下：
        (1)、addElement(Object obj): 将新元素obj添加到序列尾部。
        (2)、insertElementAt(Object obj, int index): 将指定对象obj插入到指定位置index处。
        (3)、add(int index, Object obj): 在向量的指定位置index插入指定的元素obj。
    
    2.3元素的修改或删除方法：
      使用以下方法可以修改或删除Vector类对象序列中的元素：
        (1)、setElementAt(Object obj, int index): 将指定位置index处的元素设置为obj。如果下标index是负数或超出实际元素的个数，则抛出异常ArrayIndexOutOfBoundsException。
        (2)、removeElement(Object obj): 删除向量序列中第一个与指定的obj对象相同的元素，同时将后面的所有元素均向前移一个位置。这个方法返回的是一个布尔值，表示删除操作成功与否。
        (3)、removeElementAt(int index): 删除指定index位置的元素，同时将后面的所有元素均前移一个位置。如果下标index是负数或超出实际元素的个数，则抛出异常ArrayIndexOutOfBoundsException。
        (4)、removeAllElements(): 清除向量序列中的所有元素，同时向量的大小置为0。
    
    2.4元素的查找方法：
      Java还提供了在向量序列中进行查找的操作，常用的查找方法如下：
        (1)、elementAt(int index): 返回指定位置index处的元素。如果下标index是负数或超出实际元素的个数，则抛出异常ArrayIndexOutOfBoundsException。这个方法的返回值是Object类型，在使用之前通常需要进行强制类型转换，将返回的对象引用转换成Object类的某个具体子类的对象。如：String str = (String)myVector.elementAt(0);
        (2)、contains(Object obj): 检查向量序列中是否包含指定的对象元素obj。
        (3)、indexOf(Object obj, int start_indetx): 从指定的start_index位置开始向后搜索,返回所找到的第一个与指定对象obj相同的元素的下标位置。若指定的对象不存在，则返回-1;
        (4)、lastIndexOf(Object obj, int start_indetx): 从指定的start_index位置开始向前搜索，返回所找到的第一个与指定对象obj相同的元素的下标位置。若指定的对象不存在，则返回-1;
      使用Vector时，一定要先创建后使用。如果不先使用new运算符利用构造方法创建Vect类的对象，而直接使用Vector的方法，例如addElement()等方法，则可能造成堆栈溢出或使用null指针异常等。
      程序示例在MyVectorTest.java中。

第五章小结：数组和字符串都是程序设计中经常使用的数据结构。大多数语言都提供了这两种类型。Java中，数组和字符串都是对象。
本章介绍了数组的声明，静态和动态初始化数组元素的方式。通过示例介绍了如何访问数组元素。作为一个重要的补充，本章介绍了向量类，可以将它看作是变长数组类型。
本章还介绍了String类和StringBuffer类以及类中对字符串进行操作的相关方法。


第六章 继承与多态
第一节、子类：
  Java中的类层次结构为树状结构，这和自然界中描述的一个事物是类似的。例如，可以将动物划分为哺乳类动物及爬行类动物，然后又对这两类动物继续细分。
  在Java中，可以将哺乳类动物和爬行类动物作为两个类，然后再定义一个动物类，哺乳类动物和爬行类动物都是动物类的子类。这样，就形成了一个类的继承关系。子类与父类的关系是：子类对象" is a "父类对象，也就是说，子类中的任何一个成员也是父类中的一个成员。
  在Java中，使用extends关键字来表示继承关系。使用继承这一面向对象的特性，可以支持软件的可复用性，保证了代码可以在类之间共享。
  1. is a 关系：
    在程序中，有时要建立关于某对象的模型，比如说雇员Employee，然后从这个最初的模型派生出多个具体化的版本，如经理Manager。显然，一名Manager首先是一名Employee，他具有Empolyee的一般特性。此外，Manager还有Empolyee所不具有的额外特性。
    对于Employee，可能具有的属性信息包括名字、受雇时间、生日及其他相关信息等，而对于Manager，可能还具有所管理的团队等属性信息。为此，定义两个类来表示它们。
    例如：具有一般性和特殊性的两个类：
    public class Employee {                 // 具有一般性的类
      private String name, jobTitle;
      private DatehireDate, dateOfBirth;
      private int grade;
      ...
    }
    public class Manager {                 // 具有特殊性的类
      private String name, jobTitle;
      private DatehireDate, dateOfBirth;
      private int grade;                   // 以上是与Employee共有的属性
      private String department;           // 特有的属性
      private Employee[] subordinates;     // 特有的属性
      ...
    }
    从上面的定义可以看出，Manager类和Employee类之间存在重复部分。实际上，适用于Employee的很多属性和方法可以不经修改就被Manager所使用。Manager与Employee之间存在"is a"关系，即Manager "is a" Employee。
    使用 "is a" 关系要特别注意，有些对象之间虽然也是"大"与"小"的关系，但并不是一般与特殊的关系，例如汽车又包括了车身与发动机，但不能说它们之间存在"is a"关系，它们只能是整体与部分的关系，一般地称为"has a"关系。

  2. extends关键字：
    与一般的面向对象语言一样，Java提供了派生机制，允许程序员用以前已定义的类来定义一个新类。新类称作子类，原来的类称作父类，也称为基类或超类。两个类中共同的内容放到父类中，特殊的内容放到子类中。在定义类时可以表明一个类是不是另一个类的子类。
    在Java中，使用extends关键字来表示继承，格式如下：
      修饰符 class 子类名 extends 父类名 {
        类体
      }
    例如，public class A extends B 表示A类派生于B类，A类是子类，B类是父类。如果一个类的定义中没有出现extends关键字，则表明这个类派生于Object类。Java中预定义及程序员自己定义的任何类都直接或间接地继承于Object类，Object类是所有类的父类或祖先类。
    再来考虑之前的Employee类和Manager类，很明显，它们具有"is a"关系，所以可以使用派生机制来表示它们，即可以从Empolyee类派生处Manager类，现在重新定义这两个类。
      public class Employee {
        private String name, jobTitle;
        private DatehireDate, dateOfBirth;
        private int grade;
        ...
      }
      public class Manager extends Employee {     // 派生子类
        private String department;                // 只列出Employee类中没有的属性
        private Employee[] subordinates;
        ...
      }
    Manager类中有Empolyee类的所有变量和方法，所有这些变量和方法都继承于父类中的定义。子类中只是定义额外的特性，或者进行必要的修改。
    派生机制改善了程序的可维护性，增加了可靠性。对父类Employee所做的修改延伸至子类Manager类中。

  3. Object类：
    Object类是Java程序中所有类的直接或间接父类，处在类层次的最高点。所有其他的类都是从Object类派生而来的。Object类包含了所有Java类的公共属性，其构造方法是Object()。
    类中主要的方法如下：
      (1)、public final Class getClass(): 获取当前对象所属的类信息，返回Class对象。
      (2)、public String toString():  按字符串对象返回当前对象本身的有关信息。
      (3)、public boolean equals(Object obj): 比较两个对象是否是同一个对象，是则返回true。
    关于对象相等的判别，在Java中有两种方式。一种是使用==运算符，另一种是使用equals()方法。这两种方式判定的都是两个对象是否是同一个对象(称为同一)。如果两个对象具有相同的类型及相同的属性值，则称为相等。同一的对象一定相等，但相等的对象不一定同一。
    相等判别示例：
      class BankAccount {
        private String OwnerName;
        private int AccountNumber;
        private float Balance;
        BankAccount(String name, int num1, float num2) { // 构造方法
          OwnerName = name;
          AccountNumber = num1;
          Balance = num2;
        }
        String getOwnerName() {  //返回名字
          return OwnerName;
        }
        int getAccountNumber() { // 返回账号
          return AccountNumber;
        }
        float getBalance() {  // 返回余额
          return Balance;
        }
      }
      public class EqualsTest {
        public static void main(String args[]) {
          BankAccount a = new BankAccount("张三", 123456, 1000.0f);
          BankAccount b = new BankAccount("张三", 123456, 1000.0f);
          // BankAccount b = a;  // 创建b的另一种方式
          if (a.equals(b)) {
            System.out.println("equals_YES");
          } else {
            System.out.println("equals_NO");
          }
          if (a == b) {
            System.out.println("==_YES");
          } else {
            System.out.println("==_NO");
          }  
        }
      }
    输出分别是equals_NO和==_NO，即两种方式下判定的都是同一性。由于a和b是两个独立的对象，故它们不是同一的。如果对象b不是使用new操作符来创建，而是通过赋值语句b = a来创建(如上注释掉的语句)，再来判定两个对象的相等性时，会看到输出分别是equals_YES和==_YES。
    要判断两个对象各个属性域的值是否相同，不能使用从Object类继承来的equals方法，而需要在类声明种对equals方法进行覆盖，即重新修改这个方法。例如，String类种已经重写了Object类的equals方法，故可以判定两个字符串的内容是否相同。如下，在BankAccount类中添加equals方法：
    public boolean equals(Object x) {
      if(this.getClass() != x.getClass())   // 具有相同的类型
        return false;
      BankAccount b = (BankAccount)x;
      return((this.getOwnerName().equals(b.getOwnerName()))
            &&(this.getAccountNumber() == b.getAccountNumber())
            &&(this.getBalance() == b.getBalance())); // 判定各个成员变量的值是否相等
    }
    重写的equals方法判定的是对象种的值是否相等，再次运行相等判别示例，得到的输出分别是equals_YES和==_NO。即虽然不是同一个对象，但各属性的值是对应相等的。

  4. 单重继承：
    Java是完全的面向对象语言，具有完全的OOP能力。在类的继承机制中，它抛弃了多重继承功能，仅实现了单重继承机制。
    多重继承是指从多个类共同派生一个子类，即一个类可以有多个父类。多重继承关系类似于一个网。如果子类的多个父类有同名的方法和属性，那么容易造成子类实例的混乱。这是多重继承不可克服的缺点。在Java中抛弃了多重继承，只允许单重继承。虽然如此，并没有减弱Java在继承方面的能力。
    Java中提供了接口这个概念，这是一种特殊的类，多重继承的能力通过接口来实现。总之，在Java中，如果一个类有父类，则其父类只能有一个，也就是只允许从一个类中拓展类。这条限制称为单重继承。类的继承关系构成一棵树。任何一个类都是Object类的后代。
    子类可以继承父类中的方法和成员，这个行为可以拓展，也就是说，一个类可以从其所有的祖先类(在树中通往Object的路径上的类)中继承属性及行为。虽然一个子类可以从父类及祖先类中继承所有能继承的方法和成员变量，但它不能继承构造方法。
    只有两种方式能让一个类得到构造方法，一种是自己编写构造方法；另一种方式是，在用户没有编写构造方法的时候，由系统为类提供唯一一个默认的构造方法。
    子类不能直接访问其父类中定义的私有属性及方法，但可以使用父类中定义的共有(及保护)方法访问私有数据成员。

  5. 对象转型：
    和大多数面向对象的语言一样，Java允许使用对象的父类类型的一个变量指向该对象，比如对于前面定义的Employee类和Manager类，可以将子类的对象赋给父类的变量：
      Employee e = new Manager();     // 子类Manager的实例赋给父类变量e;
    这称为对象转型(Casting)。使用变量e，可以访问Employee对象的内容，而隐藏Manager对象中的特殊内容。这是因为编译器知道e是一个Employee，而不是Manager。对象引用的赋值兼容原则允许把子类的实例赋给父类的引用。但反过来是错误的，不能把父类的实例赋给子类的引用。例如：
      Manager m = new Employee();     // 错误，不能把父类的实例赋给子类的引用
    类的变量既可以指向本类实例，又可以指向其子类的实例，这表现为对象的多态性。假定类的继承关系定义如下，层次关系如：
            ________
           | Object |
            ————————
               |                           //  类层次关系
            ________                       //  public class Employee extends Object
          | Employee |                     //  public class Manager extends Employee
            ————————                       //  public class Contractor extends Employee
               |                           //  虽然extends Object的写法完全合乎语法，但由于Object是所有类的父类，因此，这种写法是多余的。在这里，这样的写法只是为了提醒读者注意类之间的层次关系。
       ———————————————————    
      |                   |
   ________           _________
  | Manager|        | Contractor|

    在程序中，有时需要判断一个引用到底指向哪个实例，这里可以通过instanceof运算符来实现。假定，Employee类型的引用指向一个对象，但分辨不清该对象是Employee类型、Manager类型还是Contractor类型。借助于instanceof，可以判定它的真正类型。
    instanceof运算符的语法如下：
      对象 instanceof 类名
    instanceof的使用示例:
    public void method(Employee e) {
      if(e instanceof Manager) {
        // 对Manager对象进行处理
      } else if(e instanceof Contractor) {
        // 对Contractor对象进行处理
      } else {
        // 对Employee对象进行处理
      }
    }
    如果用instanceof运算符已判定父类的引用指向的是子类实例，就可以转换该引用，恢复对象的全部功能。假设已有父类Employee和子类Manager:
      public static void main(String[] args) {
        Employee betty = new Manager();  //  使用父类引用指向子类实例
        betty.name = "Betty";
        System.out.println(betty.getName());
        betty.employeeNumber = 54321;
        //betty.department = "Test";   // 这里假设子类有一个department,想直接使用将发生错误
        if (betty instanceof Manager) {
          Manager m = (Manager)betty; //  将父类引用转换为子类引用
          m.department = "Test";      //  现在可以使用department了
          System.out.println("This is the manager of " + m.getDepartment());
        }
      }
    department是Manger中的属性，不是Employee中的属性，编译器知道这一点。所以当使用Employee类的引用betty来访问这个属性(betty.department)时，编译器在Employee中找不到department成员，所以会报告错误。转型后，编译器将betty看作是Manager的实例，再访问department成员时是正确的。
    一般地，进行对象引用转型时有以下规则。
      ①沿类层次向“上”转型总是合法的，例如，把Manager引用转型为Employee引用。此种方式下不需要转型运算符，只用简单的赋值语句就可以完成。
      ②对于向“下”转型，只能是祖先类转型到后代类，其他类之间是不允许的。例如，把Manager引用转型为Contractor引用是非法的，因为Contrator不是Manager。这两个类之间没有继承关系。要替换的类(赋值号右侧)必须是当前引用类型(赋值号左侧)的父类，且要使用显式转换。

第二节、方法覆盖与多态：
  使用类的继承关系，可以从已有的类产生一个新类。在原有特性基础上，增加了新的特性。父类中原有的方法可能不能满足新的需求，因此需要修改父类中已有的方法。这就是方法覆盖(override)，也称为方法重写或隐藏。
  子类中定义方法所用的名字、返回类型及参数列表和父类中方法使用的完全一样，也就是具有相同的方法签名。此时，称子类方法覆盖(重写)了父类中的方法，从逻辑上看就是子类中的成员方法将隐藏父类中的同名方法。
  1. 方法覆盖及其规则：
    在面向对象语言程序设计中，方法覆盖是经常用到的概念。通过方法覆盖，可以达到语言多态性的目的。当子类中要做的事情(某个方法)与父类中不完全相同时，就要重写父类中的相关方法。
    当子类重写父类方法时，子类与父类使用的是相同的方法名及参数列表，但可以执行不同的功能，当然子类中也可以什么都不做。利用方法隐藏机制，子类对象的操作可以与父类中定义的不完全一样，甚至是完全不一样，从而满足了灵活性的要求。要注意的是，覆盖的同名方法中，子类方法不能比父类方法的访问权限更严格。
    例如，如果父类中方法method()的访问权限是public，则子类中就不能含有private的method()，否则，会出现编译错误。
    注意，如果方法名相同，而参数列表不同，则是对方法的重载。调用重载方法时，编译器将根据参数的个数和类型，选择对应的方法执行。重载的方法属于同一个类，覆盖的方法分属于父类，子类中。
    以Employee类和Manager类中的方法为例，重写方法(例6.7)。
      public class Employee {
        String name;
        int salary;
        public String getDetails() {
          return "Name: " + name + "\n" + "Salary: " + salary;
        }
      }
      public class Manager extends Employee {
        String department;
        public String getDetails() {      // 重写
          return "Name: " + name + "\n" + "Salary: " + salary + "\n" + "Department: " + department;
        }
      }
    Employee类和Manager类中都有getDetails()方法，可以看出，它们返回的字符串不是完全相同的。
    再以方法覆盖为例，如下：
      public class Point {
        void print() {
          System.out.println("This is the superClass!");
        }
        public static void main(String args[]) {
             Point superp = new Point();
             superp.print();     // 调用父类方法，输出"This is the superClass!"
             Point3d subp = new Point3d();    // 调用子类方法，输出"This is the subClass!"
             subp.print(); 
        }
      }
      class Point3d extends Point {
        void print() {          // 重写
          System.out.println("This is the subClass!");
        }
      }
    如果子类已经重写了父类中的方法，但在子类中还想使用父类中被隐藏的方法，可以使用super关键字。
    如下是super关键字的使用示例(例6.3)：
      class SuperClass {
        void showMyPosition() {
          System.out.println("This is the superClass!");
        }
      }
      class SubClass extends SuperClass {
        void showMyPosition() {     
          System.out.println("At first I will go to superClass!");
          super.showMyPosition();   // 调用父类方法
          System.out.println("Now I hava moved to subClass!");
        }
      }
      public class SuperTest {
        public static void main(String args[]) {
          SubClass sub = new SubClass();  // 创建子类对象
          sub.showMyPosition();           // 调用子类方法
        }
      }
    使用super时，要注意两个问题。首先，使用super.method()调用父类中的方法method(),将执行父类方法中的所有操作，其中可能会包括一些原本不希望进行的操作。所以调用时要谨慎。
    其次，由继承性的机制可以知道,super.method()语句所调用的这个方法不一定实在父类中加以描述的，它也可能是父类从它的祖先类中继承来的。因此，有可能需要按继承层次关系依次向上查询才能够找的到。
    应用覆盖时必须注意以下两条重要规则。
      ①覆盖方法的允许范围不能小于原方法。
      ②覆盖方法所抛出的异常不能比原方法更多。
    以上两条规则均源于多态性和Java所具有的"类型安全性"的要求。
    重写方法的访问权限示例：
      class SuperClass {
        public void method() { /* 相关代码 */   }
      }
      class SubClass extends SuperClass {
        private void method() { /* 相关代码 */  }   // 使用private方法覆盖public方法，编译错误
      }
    由于子类SubClass中的方法method()是private类型，而它所覆盖的父类中的原方法是public类型，这是不允许的，编译后会出现错误信息。一个重写方法也不能抛出比被重写方法更多的异常事件。

  2. 调用父类的构造方法：
    出于安全性考虑，Java对于对象的初始化要求是非常严格的。比如，Java要求一个父类的对象要在子类运行前完成初始化。
    super关键字也可用在构造方法中，其功能为调用父类的构造方法。子类不能从父类继承构造方法，在子类的构造方法中调用父类的构造方法不失为一种良好的程序设计风格。
    如果在子类构造方法的定义中没有明确调用父类的构造方法，则系统在执行子类的构造方法时会自动调用父类的默认构造方法(即无参构造方法)。
    如果在子类构造方法的定义中调用了父类的构造方法，则调用语句必须出现在子类构造方法的第一行。
    例如，调用父类的构造方法：
      class Employee {
        String name;
        public Employee(String s) {  // 构造方法
          name = s;
        }
      }
      class Manager extends Employee {
        String department;
        public Manager(String s, String d) {  // 构造方法
          super(s);                           // 调用父类构造方法
          department = d;
        }
      }
    一般来讲，调用super()时参数的个数没有限制，只要其参数列表和父类中的某个构造方法的参数列表相符即可。在通常情况下，没有参数的默认构造方法常被用来初始化父类对象。当然，也可根据具体情况先择父类其他的构造方法。
    不管怎样，如果要显式调用父类的构造方法的话，super()调用必须放在子类构造方法的开头位置。比如，下列的写法是错误的。
      public Manager(String s, String d) {
        department = d;
        super(s);   // 错误，super()调用必须放在子类构造方法的开头位置
      }
    
  3. 多态
    在Java中，多态是一个重要概念。有了多态，能够允许同一条方法调用指令在不同的上下文中做不同的事情。以例6.3中定义的3个类及例6.7中重写的方法为例。Manager类与Employee类之间具有"is a"关系，Manager得到了父类Employee的所有可继承属性，包括数据成员和方法成员。
    这意味着对Employee对象合法的操作，对Manager对象也合法。两个类中都有getDetails()方法，实际上是子类覆盖了父类中的方法。现在假定声明了如下两个实例。
      Employee e = new Employee();
      Manager m = new Manager();
    此时，e.getDetails()和m.getDetails()将执行不同的代码。e.getDetails()调用的是Employee类中的getDetails()方法，而m.getDetails()调用的是Manager类中的getDetails()方法。这不难理解。
    但如果向这样创建实例：Employee e = new Manager(); 那么e.getDetails()将调用哪个方法呢？这引出对象是多态(Polymorphism)的概念。对象e可以有Manager的形式，也可以有Employee的形式。
    重载一个方法名可以看作是多态的，父子类之间直接或间接重写的方法名要由对象在运行时确定将调用哪个方法，这也是多态。
    实际上，这正是面向对象语言的一个重要特性。Java规定，这种情况下要执行的是与对象真正类型(运行时类型)相关的方法，而不是与引用类型(编译时类型)相关的方法。
    变量的静态类型是出现在声明中的类型。例如，变量e的静态类型是Employee。静态类型也称为引用类型，是在代码编译时确定下来的。运行过程中某一时刻变量指向的对象的类型称为动态类型，这是它此刻的真正类型。变量的动态类型会随运行进程而改变。本例中e的动态类型是Manager。
    调用稍后可能被覆盖的方法的这种处理方式，称为动态绑定或后绑定。动态绑定一定要到运行时才能确定要执行的方法代码。在编译过程中能确定调用方法的处理方式，称为静态绑定或前绑定。
    例6.10 多态示例
      class SuperClass {
        public void method() {
          System.out.println("SuperClass!");
        }  
      }
      class SubClass extends SuperClass {
        public void method() {           // 覆盖方法
          System.out.println("SubClass!");
        }
      }
      public class Test {
        public static void main(String args[]) {
          SuperClass sup = new SuperClass();  // 静态类型与动态类型一致
          SubClass sub = new SubClass();      // 静态类型与动态类型一致
          SuperClass sup1 = new SubClass();   // 静态类型与动态类型不一致
          super.method();                     // 调用父类方法，输出SuperClass!
          sub.method();                       // 调用子类方法，输出SubClass!
          sup1.method();                      // 调用子类方法，输出SubClass!
        }
      }
    sub1声明的类型是SuperClass，但它指向的是SubClass的实例，所以，sub1.method()调用的是实例所属类(子类)的方法而不是所声明的类(父类)的方法。

第三节、终极类与抽象类：
  Java中有一个重要的关键字final,它表示终极，既可以修饰一个类，也可也修饰类中的成员变量或成员方法。顾名思义，用这个关键字修饰的类或类成员都是不能改变的。如果一个类被定义为final，则它不能有子类；如果一个方法被定义为final，则不能被覆盖；如果一个变量被定义为final，则它的值不能被改变。
  与之相对应的是关键字abstract，它可以用于类或方法，表示抽象。使用abstract修饰的方法的方法体为空，修饰的类必须被子类继承。
  1. 终极类：
    有时一些类不能被继承。Java中预定义的类Java.lang.String就是如此。这样做的目的是为了保证如果一个方法中有一个指向String类的引用，那么它肯定就是一个真正的String类型，而不是一个已被更改的String的子类。
    另外一种情况是某个类的结构和功能已经很完整，不需要生成它的子类，这是也应该在这个类的声明中以关键字final进行修饰。被标记为final的类将不能被继承，这样的类称为终极类或终态类，其声明的格式为：
      final class 终极类名 {
        类体
      }
    例6.11 定义一个final类FinalClass，当试图派生它的子类时，会导致错误。
      final public class FinalClass {
        int memberar;
        void memberMethod() {
        System.out.println("This is a final class!");
        } 
      }
      class subFinalClass extends FinalClass {   // 错误，不能继承终极类
        int memberar;
        void memberMethod() {
          System.out.println("This is a sub final class!");
        }
      }

  2. 终极方法：
    成员方法也可被标记为final，从而成为终极方法或终态方法。被标记为final的方法将不能被覆盖，从而可以确保被调用的方法是最原始的方法，而不是已被更改的子类中的方法。另外，把方法标记为final有时也被用于优化，从而提高编译运行效率。终极方法的定义格式为：
      final 返回类型 方法名(参数表) {
        方法体
      }
    例6.12 定义一个final方法，当试图在子类中覆盖它时，会导致错误。
      class FinalMethod {
        final void method() {
          System.out.println("This is a final method!");
        }
      }
      class subFinalMethod extends FinalMethod {
        void method() {   // 错误，不能覆盖终极方法
          System.out.println("This is a sub final method!");
        }
      }
    
  3. 终极变量：
    一个变量被标记为final，称为终极变量或终态变量。实际上它会成为一个常量。企图改变终极变量的值将引起编译错误。
    例6.13 不能改变终极变量的值：
      class Const {
        final float PI = 3.14f;     // 终极变量
        final String language = "Java";
      }
      public class UseConst {
        public static void main(String args[]) {
          Const c = new Const();
          c.PI = 3.1415926f;         // 错误，不能改变终极变量的值
        }
      }
    当程序中需要使用一些特殊用途的常量时，可以将它们定义在一个类中，其他的类通过引入该类来直接使用这些常量。这样可以保证常量使用的统一，并为修改提供了方便。
    如果将一个引用类型的变量标记为final，那么这个变量将不能再指向其他对象，但它所指对象中的属性值还是可以改变的。
    例6.14 终极引用的使用示例： 
      class Car {
        int number = 123;
      }
      Class FinalVariable {
        public static void main(String agrs[]) {
          final Car mycar = new Car();   // 终极引用
          mycar.number = 456;            // 可以，修改的是mycar指向的内存中的值
          mycar = new Car();             // 错误，不能修改mycar本身的值
        }
      }
    在这里，改变变量mycar的成员变量number的值是可以的，但如果试图用mycar指向其他对象就会引起错误。
  
  4. 抽象类：
    在程序设计过程中，有时需要创建某个类代表一些基本行为，并为其规范定义一些方法，但是又无法或不宜在这个类中就对这些行为加以具体实现，而希望在其子类中根据实际情况再去实现这些方法。
    例如，设计一个名为Drawing的类，它代表了不同绘图工具的绘图方法，但这些方法必须以平台无关的方法实现。很显然，在使用一台机器的硬件的同时，又要做到平台无关是不太可能的。因此解决的方法是，在这个类中只定义应该存在什么方法，而具体实现这些方法的工作由依赖于具体平台的子类去完成。
    像Drawing类这种定义了方法但没有定义具体实现的类称为抽象类。在Java中可以通过关键字abstract把一个类定义为抽象类，每一个未被定义具体实现的方法也应标记为abstract，这样的方法称为抽象方法。
    与一般的父类一样，在抽象类中可以包括被它的所有子类共享的公共行为，以及被它的所有子类共享的公共属性。在程序中不能用抽象类作为模板来创建对象，必须生成抽象类的一个非抽象的子类后才能创建实例。
    抽象类可以包含常规类能够包含的任何成员方法，因为子类可能需要继承这些方法。当然抽象类中也可包含构造方法。
    抽象类中通常会包含抽象方法，这种方法只有方法的声明，而没有方法的实现。这些方法将在抽象类的子类中被实现。除了抽象方法，抽象类中也可以包含非抽象方法，反之，不能在非抽象的类中定义抽象方法。也就是说，只有抽象类才能具有抽象方法。
    如果一个抽象类除了抽象方法外什么都没有，则使用接口更合适。
      抽象类和抽象方法的定义格式如下：
        public abstract class 抽象类名 {
            类体
        }
        public abstract 返回值类型 抽象方法名(参数列表); // 抽象方法
    例6.15 抽象类示例：
      abstract class Employee {
        int basic = 2000;
        abstract void salary();   // 抽象方法
      }
      class Manager extends Employee {
          void salary() {                             // 子类中的实现
          System.out.println("薪资等于:  " + basic * 5);
        }
      }
      class Works extends Employee {
        void salary() {                               // 子类中的实现
          System.out.println("薪资等于:  " + basic * 2);
        }
      }
    例6.16 抽象类示例：
      abstract class ObjectStorage {
        int objectnum = 0;
        Object storage[] = new Object[100];
        abstract void put(Object o);      // 抽象方法，没有方法体
        abstract Object get();           // 抽象方法
      }
      class Stack extends ObjectStorage {
        private int point = 0;
        public void put(Object o) {           
          storage[point++] = o;
          objectnum++;
        }
        public Object get() {                 // 实现不同
          objectnum--;
          return storage[--point];
        }
      }
      class Queue extends ObjectStorage {
        private int top = 0, bottom = 0;
        public void put(Object o) {           
          storage[top++] = o;
          objectnum++;
        }
        Object get() {                 // 实现不同
          objectnum--;
          return storage[bottom++];
        }
      }
    在这里，ObjectStorage类定义的是一般化的存储结构，其中包括成员变量objectnum和storage，分别用来记录存入的元素个数及元素本身。
    两个成员方法put()和get()只用来说明对于这样的存储结构应该具有存入和取出这两种基本操作，但是对于这两种操作的具体实现则依赖于具体的存储结构，因此，这两个方法被定义为抽象方法。相应地，ObjectStorage类也就成为抽象类，不论是类还是方法都要用关键字abstract进行修饰。
    抽象类的子类所继承的抽象方法同样还是抽象方法，除非提供了其父类中所有抽象方法的实现代码，否则子类还是抽象类。具体到本例，在ObjectStorage类的子类中，只有实现了put()和get()方法，这个子类才不是抽象类。
    一个抽象类中可以包含非抽象方法和成员变量。更明确地说，包含抽象方法的类一定是抽象类，但抽象类中的方法不一定都是抽象方法。
    抽象类是不能创建对象的，除非通过间接的方法来创建其子类的对象，但是可以定义一个抽象类的引用变量。也就是说，程序中形如new ObjectStorage()的表示是错误的，但如果子类Stack不再是抽象类，则这个语句就是正确: ObjectStorage obst = new Stack()。

第四节、接口
  接口是体现抽象类功能的另一种方式，可将其想象为一个“纯”的抽象类。它允许创建者规定一个类的基本形式，包括方法名、参数列表以及返回值类型，但不规定方法体。因此在接口中所有的方法都是抽象方法，都没有方法体。从这个角度上讲，可以把接口看成是特殊的抽象类，接口与抽象类都用来定义多个类的共同属性。
  接口还可以实现与抽象类不同的功能。具体来说，Java不支持多重继承的概念，一个类只能从唯一的一个类继承而来。但是，这并不意味着Java不能实现多重继承的功能。具体来说，Java允许一个类实现多个接口，从而实现了多重继承的能力，并具有更清晰的结构。
  1. 接口的定义：
    接口的定义格式为：
      [接口修饰符] interface 接口名 [extends 父接口列表] {
        // 方法原型或静态变量
      }
    接口与一般类一样，本身也具有数据成员变量与方法，但数据成员变量一定要赋初值，且此值不能再更改，而方法必须是“抽象方法”。
    仿照例6.16，例3.17使用接口的方式重写定义了一个存储字符的数据结构。
    例6.17 接口的定义： 
      interface CharStorage {   // 使用interface说明
        void put(char c);      // 抽象方法，没有方法体
        char get();            // 抽象方法
      }
    这个接口仅仅说明了一种数据存储结构中存在存入(put)和取出get()这样两种操作，并没有涉及具体实现。在应用时，还需要根据具体的存储结构来实现。
    在接口中定义的成员变量都默认为终极静态变量，即系统会将其自动添加final和static这两个关键字，并且对该变量必须设置初值。

  2. 接口的实现：
    接口的实现与类的继承是相似的，不过，实现接口的类不能从该接口的定义中继承任何行为。在实现该接口的类的任何对象中，都能够调用这个接口中定义的方法。一个类可以同时实现多个接口。
    要实现接口，可以在类的声明中用关键字implements来表示。接口中的所有抽象方法必须在类或子类中实现。implements语句的格式如下：
      class Stack implements CharStorage {
        private char mem[] = new char[10];
        private int point = 0;
        public void put(char c) {
          mem[point] = c;
          point++;
        }
        public char get() {
          point--;
          return mem[point];
        }
      }
    例6.19 接口的实现：
      public interface Insurable {      // 定义接口
        public int getPolicyNUmber();   // 抽象方法
        public int getCoverageAmount();
        public double calculatePremium();
        public Date getExpiryDate();
      }
      public class Car implements Insurable {         // 接口的实现
        public int getPolicyNumber() { ... }          // 获取保险单号的代码  
        public double calculatePremium() { ... }      // 计算保费的代码
        public Date getExpiryDate() { ... }           // 获取保险到期日的代码
        public int getCoverageAmount() { ... }        // 获取投保金额的代码
      }
    Java程序中，可以在implements后面声明多个接口名，也就是一个类可以实现多个接口。接口实际上就是一个特殊的抽象类，同时实现多个接口也就意味着具有多重继承的能力。
    由于在接口中的方法多是抽象方法，并不包含任何的具体代码，对这些抽象方法的实现都在具体的类中完成，因此，即使不同的接口中有同名的方法，类的实例也不会混淆。这正是Java取消了显式的多重机制，但还保留了多重继承的能力之所在。
    例如，在AWT事件处理中要经常用到接口。下面语句定义的类将实现所有鼠标事件的接口。
      public class MouseEventClass implements MouseListener, MouseMotionListener {
        ... // 所有方法的实现
      }
    如果查询Java的API文档就会发现，在MouseListener和MouseMotionListener两个接口中，分别定义了对鼠标进行各种操作时的响应。由于类MouseEventClass声明为同时实现这两个接口，因此，在实现时，该类一定要实现这两个接口中的所有方法，否则必须用abstract继续声明为抽象类。
    在实际应用中，并非接口里的所有方法都需要用到。这时有一个简单的方法，即用一对大括号来表示一个方法的空方法体。例如，在鼠标事件的接口(MouseListener和MouseMotionListener)中共定义了6种事件，假设程序不要求MouseUp事件进行任何响应，则代码可以写为: 
      public void MouseUp(Event e) {} // 不进行任何响应
    实现一个接口的类也必须实现此接口的父接口。
    程序6.4 是一个接口应用实例。定义一个接口Shape2D，利用它来实现对二维几何图形类Circle和Rectangle的操作。对二维的几何图形而言，面积的计算是很重要的，因此可以把计算面积的方法声明在接口里。求面积时使用的pi值是常量，可以把它声明在接口的数据成员里。
      程序6.4 接口应用示例：
        interface Shape2D {
          final double pi = 3.1415926;     // 常量
          public abstract double area();   // 抽象方法
        }
        // 定义Circle与Rectangele两个类，它们都实现了Shape2D接口
        class Circle implements Shape2D {
          double radius;
          public Circle(double r) { radius = r; }           // 构造方法
          public double area() { return pi * radius * radius; } // 计算面积
        }
        class Rectangle implements Shape2D {
          int width, height;
          public Rectangle(int w, int h) { width = w; height = h; } // 构造方法
          public double area() { return width * height; }            // 计算面积
        }
        // 定义测试类
        public class InterfaceTester {
          public static void main(String args[]) {
            Circle c = new Circle(2.0);
            System.out.println("圆的面积是：" + c.area());
            Rectangle r = new Rectangle(5, 6);
            System.out.println("矩形的面积是：" + r.area());                       
          }
        }
    在接口的定义中，Java允许省略定义数据成员的final关键字、方法的public及abstract关键字，因此程序6.4中的接口也可以是这样的的：
      interface Shape2D {
        double pi = 3.1415926;     // 数据成员一定要初始化
        double area();             // 抽象方法
      }  
    不能直接由接口来创建对象，而必须通过由实现接口的类来创建。同抽象类一样，使用接口名作为一个引用变量的类型也是允许的，既可以声明接口类型的变量(或数组)，并用它来访问对象。该引用可以用来指向任何实现了该接口的类的实例。使用时将根据动态绑定的原则，视该变量所指向的具体实例来进行操作。
    例如：
      public class VariableTester { 
        public static void main(String args[]) {
          Shape2D var1, var2;             // 接口类型的变量
          var1 = new Rectangle(5 , 6);    // 接口引用指向类的实例
          System.out.println("矩形的面积是：" + var1.area());
          var2 = new Circle(2.0);         // 接口引用指向类的实例
          System.out.println("圆的面积是：" + var2.area());
        }
      }

第六章小结：
  本章继续介绍有关面向对象的内容。介绍子类与继承、方法的覆盖和多态等概念，此外还介绍了终极类及抽象类的概念及用法。接口也是重要的概念，是实现多重继承的唯一途径，本章也介绍了接口及类实现接口的方式。
  本章的内容是面向对象程序设计的精髓所在，要能使用extends关键字声明子类，能够正确进行对象转型。要能够区分方法覆盖于方法重载，能够掌握调用本类及父类中的方法、覆盖父类中的方法，从而全面掌握多态的概念。


第七章、输入和输出流
第一节、数据流的基本概念：
  几乎所有的程序都离不开信息的输入和输出，比如从键盘读取数据，从文件中获取或者向文件存入数据，在显示器上显示数据。这些情况下都会涉及有关输入/输出的处理。在Java中，把这些不同类型的输入、输出源抽象为流(Stream)，其中输入或输出的数据称为数据流(Data Stream),用统一的接口来表示。
  数据流是指一组有顺序的、有起点和终点的字节集合。程序从键盘接收数据或向文件中写数据，都可以使用数据流来完成。
  流被组织成不同的层次，数据流分为输入数据流和输出数据流。输入数据流只能读不能写，而输出数据流只能写不能读。从数据流中读取数据时，必须有一个数据源与该数据流相连。
  Java.io包中提供了表示数据流的4个基本抽象类，分别是InputStream、OutputStream、Reader和Writer。此外，包中还有其他常用的数据流，因此在涉及数据流操作的程序中，几乎都要使用引入语句：import java.io.*; 才能够使用这些由环境本身提供的数据流类。
  最初的版本中，Java.io包中的流只有普通的字节流，即以byte为基本处理单位的流。字节流用来读写8位的数据，由于不会对数据作任何转换，因此可以用来处理二进制的数据。在后来的版本中，java.io包中又加入了专门用于字符流处理的类，这是以Reader和Writer为基础派生的一系列的类。

  1. 输入数据流：
    输入数据流是指只能读不能写的数据流，用于向计算机内输入信息使用。
    java.io包中所有输入数据流都是从抽象类InputStream继承而来，并且实现了其中所有的方法，包括读取数据、标记位置、重置读写指针、获取数据量等。从数据流中读取数据时，必须有一个数据源与该数据流相连。
    输入数据流中提供的主要数据操作方法如下：
      ①int read(): 从输入流中读取一个字节的二进制数据。
      ②int read(byte[] b):  将多个字节读到数组中，填满整个数组。
      ③int read(byte[] b, int off, int len):  从输入流中读取长度为len的数据，从数组b中下标为off的位置开始放置读入的数据，读毕后返回读取的字节数。
    这三个方法提供了访问数据流中数据的方法，所读取的数据都默认为字节类型。第一个read()方法将读取的一个字节作为低位，形成一个0~255的int类型的数值返回。它是一个抽象方法，需要在子类中具体实现。
    以上3个方法中，当输入流读取结束时，会得到-1，以标志数据流的结束。在实际应用中，为提高效率，读取数据时经常以系统允许的最大数据块长度为单位读取。也就是说要与一个后面即将讨论的BufferInputStream相连。
      ④void close(): 关闭数据流。
    当结束对一个数据流的操作时应该将其关闭，同时释放与该数据流相关的资源，因为Java提供系统级的垃圾自动回收功能，所以当一个流对象不再使用时，系统可以自动关闭。但是，为提高程序的安全性和可读性，建议显式关闭输入/输出流。
      ⑤int available(): 返回目前可以从数据流中读取的字节数。(但实际的读操作所读得的字节数可能大于该返回值)。
      ⑥long skip(long 1): 跳过数据流中指定数量的字节不读取，返回值表示实际跳过的字节数。
    对数据流中字节的读取通常是按从头到尾顺序进行的，如果需要以反方向读取，则需要使用回推(Push Back)操作。在支持回推操作的数据流中经常用到如下几个方法：
      ⑦boolean markSupported(): 用于测试数据流是否支持回推操作，当一个数据流支持mark()和reset()方法时返回true，否则返回false。
      ⑧void mark(intmarkarea): 用于标记数据流的当前位置，并划出一个缓冲区，其大小至少为指定参数的大小。
      ⑨void reset(): 将输入流重新定位到对此流最后调用mark方法时的位置。
    
  2. 输出数据流：
    输出数据流是指只能写不能读的流，用于从计算机中输出数据。
    与输入流类似，java.io包中所有输出数据流大多是从抽象类OutputStream继承而来的，并且实现了其中的所有方法，这些方法主要提供了关于数据输出方面的支持。
    输出数据流中提供的主要数据操作方法发如下：
      ①void write(int i): 将字节i写入到数据流中，它只输出所读入参数的最低8位。该方法时抽象方法，需要在其输出流子类中加以实现，然后才能使用。
      ②void write(byte b[]): 将数组b[]中的全部b.length个字节写入数据流。
      ③void write(byte b[], int off, int len): 将数组b[]中从下标off开始的len个字节写入数据流。元素b[off]是此操作写入的第一个字节，b[off+len-1]是此操作写入的最后一个字节。
    以上这些方法用于向输出数据流中写数据。在实际应用中，和操作输入流一样，通常以系统允许的最大数据块长度为单位进行写操作。
      ④void close(): 当结束对输出数据流的操作时应该将其关闭。
      ⑤void flush(): 刷新此输出流并强制写出所有缓冲的输出字节。
    在目前通用的存储介质中内存访问的速度是最快的，因此，为加快数据传输速度，提高数据输出效率，有时输出数据流会在提交数据之前把所要输出的数据先暂时保存在内存缓冲区中，然后成批进行输出，每次传输过程都以某特定数据长度为单位进行传输。
    在这种方式下，数据的末尾一般都会有一部分数据由于数量不够一个批次，而存留在缓冲区里，调用方法flush()可以将这部分数据强制提交。
    
第二节、基本字节数据流类：
  InputStream和OutputStream两个类都是抽象类。抽象类时不能进行实例化的，因此，在实际应用中经常用到的并不是这两个类，而是一系列基本数据流类。它们都是InputStream和OutputStream的子类。在实现其父类方法的同时又定义了其特有的功能。
  1. 文件数据流：
    文件数据流包括FileInputStream和FileOutputStream，这两个类用来进行文件的I/O处理，其数据源或数据终点都应当是文件。通过所提供的方法可以对本机上的文件进行操作，但是不支持方法mark()和reset()。在构造文件数据流时可以直接给出文件名。
    例7.1 文件数据流示例：
      FileInputStream fis = new FileInputStream("a.txt");
    这样，便把文件a.txt作为该数据流的数据源。
    同样可以使用FileOutputStream向文件中输出字节。
    使用文件数据流进行I/O操作时，对于FileInputStream类的实例对象，如果所指定的文件不存在，则产生FileNotFoundException异常。由于它是非运行时异常，因此必须加以捕获或声明。对于FileOutputStream类的实例对象，如果指定的文件不存在，则系统会创建一个新文件；如果存在，那么新写入的内容将会覆盖原有数据。
    如果在读、写文件或生成新文件时发生错误，则会产生IOException异常，也需要由程序员捕获并处理。
    例7.1 文件数据流示例：
      import java.io.*;
      public class Test{
        public static void main(String[] args) {

          try {  
            FileOutputStream out = new FileOutputStream("myFile.dat");
            out.write('A');
            out.write('B');
            out.close();
          } catch (FileNotFoundException e) {
            System.out.println("找不到文件");
          } catch (IOException e) {
            System.out.println("文件写入错误");
          }
        }  
      }
    可以使用FileInputStream来读取FileOutputStream输出的数据。
    例7.2 读写示例：
      import java.io.*;
      public class Test{
        public static void main(String[] args) {
          try {
            FileInputStream in = new FileInputStream("myFile.dat");
            while(in.available() > 0)
              System.out.print(in.read() + " ");
            in.close();
          } catch(FileNotFoundException e) {
            System.out.println("Error: Cannot open file for reading. ");
          } catch(EOFEXception e) {
            System.out.println("Error: EOF encountered,file may be corrupted. ");
          } catch(IOException e) {
            System.out.println("Error: Cannot read from file. ");
          }
        }
      }
  
  2. 过滤器数据流：
    本小节介绍另外一种数据流，即过滤器(filter)。一个过滤器数据流在创建时与一个已经存在的数据流相连，这样在从这样的数据流中读取数据时，它提供的是对一个原始输入数据流的内容进行了特定处理的数据。
    2.1 缓冲区数据流：
      缓冲区数据流由BufferedInputStream和BufferOutputStream，它们是在数据流上增加了一个缓冲区，都属于过滤器数据流。当读写数据时，数据以块为单位先进入缓冲区(块的大小可以进行设置)，其后的读写操作则作用于缓冲区。
      采用这个办法可以降低不同硬件设备之间速度的差异，提高I/O操作的效率。与此同时，这两个流还提供了对mark()、reset()和skip()等方法的支持。
      在创建该类的实例对象时，可以使用两种方法，一种是使用默认缓冲区的大小，例如：
        FileInputStream fis = new FileInputStream("myFile");
        InputStream is = new BufferedInputStream(fis);
        FileOutputStream fos = new FileOutputStream("myFile");
        OutputStream os = new BufferedOutputStream(fos);
      另一种是自行设置缓冲区的大小，例如：
        FileInputStream fis = new FileInputStream("myFile");
        InputStream is = new BufferedInputStream(fis, 1024);
        FileOutputStream fos = new FileOutputStream("myFile");
        OutputStream os = new BufferedOutputStream(fos, 1024);
      一般在关闭一个缓冲区输出流之前，应先使用flush()方法，强制输出剩余数据，以确保缓冲区内的所有数据全部写入输出流。
    
    2.2 数据数据流：
      在前面提到的数据流中处理的数据都是指字节或字节数组，这是进行数据传输时系统默认的数据类型。但实际上所处理的数据并非只有这两种类型，遇到这种情况时就应用一种专门的数据流来处理。
      DataInputStream和DataOutputStream就是这样的两个过滤器数据流，它们允许通过数据流来读写Java基本类型，包括布尔型(boolean)、浮点型(float)等。假设is和os分别是前面已经建好的输入/输出数据流对象，则数据流的创建方式如下。
        DataInputStream dis = new DataInputStream(is);
        DataOutputStream dos = new DataOutputStream(os);
      在这两个类中之所以能够对这些基本类型进行操作，是因为它们提供了一组特定的方法来操作不同的基本类型。例如，在DataInputStream类中，提供了如下一些方法。
        ①byte readByte()
        ②long readLong()
        ③double readDouble()
        ④boolean readBoolean()
        ⑤String readUTF()
        ⑥int readInt()
        ⑦float readFloat()
        ⑧short readShort()
        ⑨char readChar()
      从方法名字就可以判断出，上述方法分别对byte、long、double和boolean等类型进行读取。
      相应的，在DataOutputStream类中提供了如下的方法。
        ①void writeByte(int b)
        ②void writeLong(long l)
        ③void writeDouble(double d)
        ④void writeBoolean(boolean b)
        ⑤void writeUTF(String str)
        ⑥void writeInt(int i)
        ⑦void writeFloat(float f)
        ⑧void writeShort(short s)
        ⑨void writeChar(char c)
      同样地，上述方法分别对byte、long、double和boolean等类型进行写入。
      可以看出DataInputStream的方法与DataOutputStream的方法都是成对出现的。
      如果查询API文档，就会发现在这两个数据流中也都定义了对字符串进行读写的方法，但是，由于字符编码的原因，应该避免使用这些方法。后面将要讲到Reader和Writer重载了这两个方法，当对字符串进行操作时应该使用Reader和Writer两个系列类中的方法。

    3. 对象流
      Java中的数据流不仅能对基本数据类型的数据进行操作，而且也提供了把对象写入文件数据流或文件数据流中读出的功能，这一功能是通过java.io包中的ObjectInputStream和ObjectOutputStream两个类来实现的。能够输入/输出对象的流称为对象流。
      3.1 写对象数据流：
        例7.2中的代码段将一个java.util.Date对象实例写入文件。
        例7.2 对象流示例：
          Date d = new Date();             // 一个对象d
          FileOutputStream f = new FileOutputStream("date.ser");
          ObjectOutputStream s = new ObjectOutputStream(f); // 输出文件
          try {
            s.writeObject(d);
            s.close();                    // 将对象d写入文件，关闭文件
          } catch(IOException) {
            e.printStackTrace();
          }
      
      3.2 读对象数据流：
        读对象和写对象一样简单，但是要注意，方法readObject()把数据流以Object类型返回，返回内容应该在转换为正确的类名之后再执行该类的方法。
        例7.3 对象流示例： 
          Date d = null;                  
          FileInputStream f = new FileInputStream("date.ser");
          ObjectInputStream s = new ObjectInputStream(f); // 输入文件
          try {
            d = (Date)s.readObject();      // 读取对象
            s.close();                     // 关闭文件
          } catch(IOException e) {
            e.printStackTrace();
          }
          System.out.println("Date serialized at " + d); 
    
    4. 序列化：
      4.1 序列化的概念：
        能够记录自己的状态以便将来得到复原的能力，称为对象的持久性(Persistence)。称一个对象是可持久的，意味着可以把这个对象存入磁盘，磁带，或传入另一台计算机保存在它的内存或磁盘中。也就是说，把对象存为某种永久存储类型。
        对象通过数值来描述自己的状态，记录对象也就是记录下这些数值。把对象转换为字节序列的过程称为对象的序列化，把字节序列恢复为对象的过程称为对象的反序列化。序列化的主要任务是写出对象实例的数值。
        序列化是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。序列化时为了解决在对对象流进行读写操作时所英法的问题。
        如果变量是另一个对象的引用，则引用的对象也要序列化。这个过程是递归的，保存的结果可以看作是一个对象网。







  


     
  


     
     

     
    
    





  




    









